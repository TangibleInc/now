{"version":3,"file":"index.js","sources":["../../../../packages/php-wasm/fs-journal/src/lib/fs-journal.ts"],"sourcesContent":["import { PHP, UniversalPHP, __private__dont__use } from '@php-wasm/universal';\nimport { Semaphore, basename, joinPaths } from '@php-wasm/util';\nimport { logger } from '@php-wasm/logger';\n\nexport type EmscriptenFS = any;\n\n/**\n * Represents a stream in the Emscripten file system.\n */\nexport type EmscriptenFSStream = {\n\t/** The path of the node associated with this stream. */\n\tpath: string;\n\t/** The node associated with the stream. */\n\tnode: EmscriptenFSNode;\n};\n\n/**\n * Represents a node in the Emscripten file system.\n */\nexport type EmscriptenFSNode = {\n\t/**\n\t * The name of the file or directory.\n\t */\n\tname: string;\n\t/**\n\t * A binary flag encoding information about this note,\n\t * e.g. whether it's file or a directory.\n\t */\n\tmode: number;\n\t/**\n\t * A dictionary of functions representing operations\n\t * that can be performed on the node.\n\t */\n\tnode_ops: any;\n};\n\n/**\n * Represents the type of node in PHP file system.\n */\nexport type FSNodeType = 'file' | 'directory';\n\n/**\n * Represents an update operation on a file system node.\n */\nexport type UpdateFileOperation = {\n\t/** The type of operation being performed. */\n\toperation: 'WRITE';\n\t/** The path of the node being updated. */\n\tpath: string;\n\t/** Optional. The new contents of the file. */\n\tdata?: Uint8Array;\n\tnodeType: 'file';\n};\n\n/**\n * Represents a directory operation.\n */\nexport type CreateOperation = {\n\t/** The type of operation being performed. */\n\toperation: 'CREATE';\n\t/** The path of the node being created. */\n\tpath: string;\n\t/** The type of the node being created. */\n\tnodeType: FSNodeType;\n};\n\nexport type DeleteOperation = {\n\t/** The type of operation being performed. */\n\toperation: 'DELETE';\n\t/** The path of the node being updated. */\n\tpath: string;\n\t/** The type of the node being updated. */\n\tnodeType: FSNodeType;\n};\n\n/**\n * Represents a rename operation on a file or directory in PHP file system.\n */\nexport type RenameOperation = {\n\t/** The type of operation being performed. */\n\toperation: 'RENAME';\n\t/** The original path of the file or directory being renamed. */\n\tpath: string;\n\t/** The new path of the file or directory after the rename operation. */\n\ttoPath: string;\n\t/** The type of node being renamed (file or directory). */\n\tnodeType: FSNodeType;\n};\n\n/**\n * Represents a node in the file system.\n */\nexport type FSNode = {\n\t/** The name of this file or directory. */\n\tname: string;\n\t/** The type of this node (file or directory). */\n\ttype: FSNodeType;\n\t/** The contents of the file, if it is a file and it's stored in memory. */\n\tcontents?: string;\n\t/** The child nodes of the directory, if it is a directory. */\n\tchildren?: FSNode[];\n};\n\nexport type FilesystemOperation =\n\t| CreateOperation\n\t| UpdateFileOperation\n\t| DeleteOperation\n\t| RenameOperation;\n\nexport function journalFSEvents(\n\tphp: PHP,\n\tfsRoot: string,\n\tonEntry: (entry: FilesystemOperation) => void = () => {}\n) {\n\tfunction bindToCurrentRuntime() {\n\t\tfsRoot = normalizePath(fsRoot);\n\t\tconst FS = php[__private__dont__use].FS;\n\t\tconst FSHooks = createFSHooks(FS, (entry: FilesystemOperation) => {\n\t\t\t// Only journal entries inside the specified root directory.\n\t\t\tif (entry.path.startsWith(fsRoot)) {\n\t\t\t\tonEntry(entry);\n\t\t\t} else if (\n\t\t\t\tentry.operation === 'RENAME' &&\n\t\t\t\tentry.toPath.startsWith(fsRoot)\n\t\t\t) {\n\t\t\t\tfor (const op of recordExistingPath(\n\t\t\t\t\tphp,\n\t\t\t\t\tentry.path,\n\t\t\t\t\tentry.toPath\n\t\t\t\t)) {\n\t\t\t\t\tonEntry(op);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Override the original FS functions with ones running the hooks.\n\t\t * We could use a Proxy object here if the Emscripten JavaScript module\n\t\t * did not use hard-coded references to the FS object.\n\t\t */\n\t\tconst originalFunctions: Record<string, Function> = {};\n\t\tfor (const [name] of Object.entries(FSHooks)) {\n\t\t\toriginalFunctions[name] = FS[name];\n\t\t}\n\n\t\t// eslint-disable-next-line no-inner-declarations\n\t\tfunction bind() {\n\t\t\tfor (const [name, hook] of Object.entries(FSHooks)) {\n\t\t\t\tFS[name] = function (...args: any[]) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\thook(...args);\n\t\t\t\t\treturn originalFunctions[name].apply(this, args);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\t// eslint-disable-next-line no-inner-declarations\n\t\tfunction unbind() {\n\t\t\t// Restore the original FS functions.\n\t\t\tfor (const [name, fn] of Object.entries(originalFunctions)) {\n\t\t\t\tphp[__private__dont__use].FS[name] = fn;\n\t\t\t}\n\t\t}\n\n\t\tphp[__private__dont__use].journal = {\n\t\t\tbind,\n\t\t\tunbind,\n\t\t};\n\t\tbind();\n\t}\n\tphp.addEventListener('runtime.initialized', bindToCurrentRuntime);\n\tif (php[__private__dont__use]) {\n\t\tbindToCurrentRuntime();\n\t}\n\n\tfunction unbindFromOldRuntime() {\n\t\tphp[__private__dont__use].journal.unbind();\n\t\tdelete php[__private__dont__use].journal;\n\t}\n\tphp.addEventListener('runtime.beforedestroy', unbindFromOldRuntime);\n\n\treturn function unbind() {\n\t\tphp.removeEventListener('runtime.initialized', bindToCurrentRuntime);\n\t\tphp.removeEventListener('runtime.beforedestroy', unbindFromOldRuntime);\n\t\treturn php[__private__dont__use].journal.unbind();\n\t};\n}\n\nconst createFSHooks = (\n\tFS: EmscriptenFS,\n\trecordEntry: (entry: FilesystemOperation) => void = () => {}\n) => ({\n\twrite(stream: EmscriptenFSStream) {\n\t\trecordEntry({\n\t\t\toperation: 'WRITE',\n\t\t\tpath: stream.path,\n\t\t\tnodeType: 'file',\n\t\t});\n\t},\n\ttruncate(path: string) {\n\t\tlet node;\n\t\tif (typeof path == 'string') {\n\t\t\tconst lookup = FS.lookupPath(path, {\n\t\t\t\tfollow: true,\n\t\t\t});\n\t\t\tnode = lookup.node;\n\t\t} else {\n\t\t\tnode = path;\n\t\t}\n\t\trecordEntry({\n\t\t\toperation: 'WRITE',\n\t\t\tpath: FS.getPath(node),\n\t\t\tnodeType: 'file',\n\t\t});\n\t},\n\tunlink(path: string) {\n\t\trecordEntry({\n\t\t\toperation: 'DELETE',\n\t\t\tpath,\n\t\t\tnodeType: 'file',\n\t\t});\n\t},\n\tmknod(path: string, mode: number) {\n\t\tif (FS.isFile(mode)) {\n\t\t\trecordEntry({\n\t\t\t\toperation: 'CREATE',\n\t\t\t\tpath,\n\t\t\t\tnodeType: 'file',\n\t\t\t});\n\t\t}\n\t},\n\tmkdir(path: string) {\n\t\trecordEntry({\n\t\t\toperation: 'CREATE',\n\t\t\tpath,\n\t\t\tnodeType: 'directory',\n\t\t});\n\t},\n\trmdir(path: string) {\n\t\trecordEntry({\n\t\t\toperation: 'DELETE',\n\t\t\tpath,\n\t\t\tnodeType: 'directory',\n\t\t});\n\t},\n\trename(old_path: string, new_path: string) {\n\t\ttry {\n\t\t\tconst oldLookup = FS.lookupPath(old_path, {\n\t\t\t\tfollow: true,\n\t\t\t});\n\t\t\tconst newParentPath = FS.lookupPath(new_path, {\n\t\t\t\tparent: true,\n\t\t\t}).path;\n\n\t\t\trecordEntry({\n\t\t\t\toperation: 'RENAME',\n\t\t\t\tnodeType: FS.isDir(oldLookup.node.mode) ? 'directory' : 'file',\n\t\t\t\tpath: oldLookup.path,\n\t\t\t\ttoPath: joinPaths(newParentPath, basename(new_path)),\n\t\t\t});\n\t\t} catch (e) {\n\t\t\t// We're running a bunch of FS lookups that may fail at this point.\n\t\t\t// Let's ignore the failures and let the actual rename operation\n\t\t\t// fail if it needs to.\n\t\t}\n\t},\n});\n\n/**\n * Replays a list of filesystem operations on a PHP instance.\n *\n * @param php\n * @param entries\n */\nexport function replayFSJournal(php: PHP, entries: FilesystemOperation[]) {\n\t// We need to restore the original functions to the FS object\n\t// before proceeding, or each replayed FS operation will be journaled.\n\t//\n\t// Unfortunately we can't just call the non-journaling versions directly,\n\t// because they call other low-level FS functions like `FS.mkdir()`\n\t// and will trigger the journaling hooks anyway.\n\tphp[__private__dont__use].journal.unbind();\n\ttry {\n\t\tfor (const entry of entries) {\n\t\t\tif (entry.operation === 'CREATE') {\n\t\t\t\tif (entry.nodeType === 'file') {\n\t\t\t\t\tphp.writeFile(entry.path, ' ');\n\t\t\t\t} else {\n\t\t\t\t\tphp.mkdir(entry.path);\n\t\t\t\t}\n\t\t\t} else if (entry.operation === 'DELETE') {\n\t\t\t\tif (entry.nodeType === 'file') {\n\t\t\t\t\tphp.unlink(entry.path);\n\t\t\t\t} else {\n\t\t\t\t\tphp.rmdir(entry.path);\n\t\t\t\t}\n\t\t\t} else if (entry.operation === 'WRITE') {\n\t\t\t\tphp.writeFile(entry.path, entry.data!);\n\t\t\t} else if (entry.operation === 'RENAME') {\n\t\t\t\tphp.mv(entry.path, entry.toPath);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tphp[__private__dont__use].journal.bind();\n\t}\n}\n\nexport function* recordExistingPath(\n\tphp: PHP,\n\tfromPath: string,\n\ttoPath: string\n): Generator<FilesystemOperation> {\n\tif (php.isDir(fromPath)) {\n\t\t// The rename operation moved a directory from outside root directory\n\t\t// into the root directory. We need to traverse the entire tree\n\t\t// and provide a create operation for each file and directory.\n\t\tyield {\n\t\t\toperation: 'CREATE',\n\t\t\tpath: toPath,\n\t\t\tnodeType: 'directory',\n\t\t};\n\t\tfor (const file of php.listFiles(fromPath)) {\n\t\t\tyield* recordExistingPath(\n\t\t\t\tphp,\n\t\t\t\tjoinPaths(fromPath, file),\n\t\t\t\tjoinPaths(toPath, file)\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// The rename operation moved a file from outside root directory\n\t\t// into the root directory. Let's rewrite it as a create operation.\n\t\tyield {\n\t\t\toperation: 'CREATE',\n\t\t\tpath: toPath,\n\t\t\tnodeType: 'file',\n\t\t};\n\t\tyield {\n\t\t\toperation: 'WRITE',\n\t\t\tnodeType: 'file',\n\t\t\tpath: toPath,\n\t\t};\n\t}\n}\n\nfunction normalizePath(path: string) {\n\treturn path.replace(/\\/$/, '').replace(/\\/\\/+/g, '/');\n}\n\n/**\n * Normalizes a list of filesystem operations to remove\n * redundant operations.\n *\n * This is crucial because the journal doesn't store the file contents\n * on write, but only the information that the write happened. We only\n * read the contents of the file on flush. However, at that time the file\n * could have been moved to another location so we need this function to\n * rewrite the journal to reflect the current file location. Only then\n * will the hydrateUpdateFileOps() function be able to do its job.\n *\n * @param journal The original journal.\n * @returns The normalized journal.\n */\nexport function normalizeFilesystemOperations(\n\tjournal: FilesystemOperation[]\n): FilesystemOperation[] {\n\tconst substitutions: Record<number, any> = {};\n\tfor (let i = journal.length - 1; i >= 0; i--) {\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst formerType = checkRelationship(journal[i], journal[j]);\n\t\t\tif (formerType === 'none') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst latter = journal[i];\n\t\t\tconst former = journal[j];\n\t\t\tif (\n\t\t\t\tlatter.operation === 'RENAME' &&\n\t\t\t\tformer.operation === 'RENAME'\n\t\t\t) {\n\t\t\t\t// Normalizing a double rename is a complex scenario so let's just give\n\t\t\t\t// up. There's just too many possible scenarios to handle.\n\t\t\t\t//\n\t\t\t\t// For example, the following scenario may not be possible to normalize:\n\t\t\t\t// RENAME /dir_a /dir_b\n\t\t\t\t// RENAME /dir_b/subdir /dir_c\n\t\t\t\t// RENAME /dir_b /dir_d\n\t\t\t\t//\n\t\t\t\t// Similarly, how should we normalize the following list?\n\t\t\t\t// CREATE_FILE /file\n\t\t\t\t// CREATE_DIR /dir_a\n\t\t\t\t// RENAME /file /dir_a/file\n\t\t\t\t// RENAME /dir_a /dir_b\n\t\t\t\t// RENAME /dir_b/file /dir_b/file_2\n\t\t\t\t//\n\t\t\t\t// The shortest way to recreate the same structure would be this:\n\t\t\t\t// CREATE_DIR /dir_b\n\t\t\t\t// CREATE_FILE /dir_b/file_2\n\t\t\t\t//\n\t\t\t\t// But that's not a straightforward transformation so let's just not\n\t\t\t\t// handle it for now.\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'[FS Journal] Normalizing a double rename is not yet supported:',\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrent: latter,\n\t\t\t\t\t\tlast: former,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (former.operation === 'CREATE' || former.operation === 'WRITE') {\n\t\t\t\tif (latter.operation === 'RENAME') {\n\t\t\t\t\tif (formerType === 'same_node') {\n\t\t\t\t\t\t// Creating a node and then renaming it is equivalent to creating\n\t\t\t\t\t\t// it in the new location.\n\t\t\t\t\t\tsubstitutions[j] = [];\n\t\t\t\t\t\tsubstitutions[i] = [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t...former,\n\t\t\t\t\t\t\t\tpath: latter.toPath,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t...(substitutions[i] || []),\n\t\t\t\t\t\t];\n\t\t\t\t\t} else if (formerType === 'descendant') {\n\t\t\t\t\t\t// Creating a node and then renaming its parent directory is\n\t\t\t\t\t\t// equivalent to creating it in the new location.\n\t\t\t\t\t\tsubstitutions[j] = [];\n\t\t\t\t\t\tsubstitutions[i] = [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t...former,\n\t\t\t\t\t\t\t\tpath: joinPaths(\n\t\t\t\t\t\t\t\t\tlatter.toPath,\n\t\t\t\t\t\t\t\t\tformer.path.substring(latter.path.length)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t...(substitutions[i] || []),\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\tlatter.operation === 'WRITE' &&\n\t\t\t\t\tformerType === 'same_node'\n\t\t\t\t) {\n\t\t\t\t\t// Updating the same node twice is equivalent to updating it once\n\t\t\t\t\t// at the later time.\n\t\t\t\t\tsubstitutions[j] = [];\n\t\t\t\t} else if (\n\t\t\t\t\tlatter.operation === 'DELETE' &&\n\t\t\t\t\tformerType === 'same_node'\n\t\t\t\t) {\n\t\t\t\t\t// Creating a node and then deleting it is equivalent to doing\n\t\t\t\t\t// nothing.\n\t\t\t\t\tsubstitutions[j] = [];\n\t\t\t\t\tsubstitutions[i] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Any substiturions? Apply them and and start over.\n\t\t// We can't just continue as the current operation may\n\t\t// have been replaced.\n\t\tif (Object.entries(substitutions).length > 0) {\n\t\t\tconst updated = journal.flatMap((op, index) => {\n\t\t\t\tif (!(index in substitutions)) {\n\t\t\t\t\treturn [op];\n\t\t\t\t}\n\t\t\t\treturn substitutions[index];\n\t\t\t});\n\t\t\treturn normalizeFilesystemOperations(updated);\n\t\t}\n\t}\n\treturn journal;\n}\n\ntype RelatedOperationInfo = 'same_node' | 'ancestor' | 'descendant' | 'none';\nfunction checkRelationship(\n\tlatter: FilesystemOperation,\n\tformer: FilesystemOperation\n): RelatedOperationInfo {\n\tconst latterPath = latter.path;\n\tconst latterIsDir =\n\t\tlatter.operation !== 'WRITE' && latter.nodeType === 'directory';\n\tconst formerIsDir =\n\t\tformer.operation !== 'WRITE' && former.nodeType === 'directory';\n\tconst formerPath =\n\t\tformer.operation === 'RENAME' ? former.toPath : former.path;\n\n\tif (formerPath === latterPath) {\n\t\treturn 'same_node';\n\t} else if (formerIsDir && latterPath.startsWith(formerPath + '/')) {\n\t\treturn 'ancestor';\n\t} else if (latterIsDir && formerPath.startsWith(latterPath + '/')) {\n\t\treturn 'descendant';\n\t}\n\treturn 'none';\n}\n\n/**\n * Populates each WRITE operation with the contents of\n * said file.\n *\n * Mutates the original array.\n *\n * @param php\n * @param entries\n */\nexport async function hydrateUpdateFileOps(\n\tphp: UniversalPHP,\n\tentries: FilesystemOperation[]\n) {\n\tconst updateFileOps = entries.filter(\n\t\t(op): op is UpdateFileOperation => op.operation === 'WRITE'\n\t);\n\tconst updates = updateFileOps.map((op) => hydrateOp(php, op));\n\tawait Promise.all(updates);\n\treturn entries;\n}\n\nconst hydrateLock = new Semaphore({ concurrency: 15 });\nasync function hydrateOp(php: UniversalPHP, op: UpdateFileOperation) {\n\tconst release = await hydrateLock.acquire();\n\n\t// There is a race condition here:\n\t// The file could have been removed from the filesystem\n\t// between the flush() call and now. If that happens, we won't\n\t// be able to read it here.\n\t//\n\t// If the file was DELETEd, we're fine as the next flush() will\n\t// propagate the DELETE operation.\n\t//\n\t// If the file was RENAMEd, we're in trouble as we're about to\n\t// tell the other peer to create an empty file and the next\n\t// flush() will rename that empty file.\n\t//\n\t// This issue requires a particular timing and is unlikely to ever happen,\n\t// but is definitely possible. We could mitigate it by either:\n\t//\n\t// * Peeking into the buffered journal entries since the last flush() to\n\t//   source the file path from\n\t// * Storing the data at the journaling stage instead of the flush() stage,\n\t//   (and using potentially a lot of additional memory to keep track of all\n\t//    the intermediate stages)\n\t//\n\t// For now, htough, let's just add error logging and keep an eye on this\n\t// to see if this actually ever happens.\n\ttry {\n\t\top.data = await php.readFileAsBuffer(op.path);\n\t} catch (e) {\n\t\t// Log the error but don't throw.\n\t\tlogger.warn(\n\t\t\t`Journal failed to hydrate a file on flush: the ` +\n\t\t\t\t`path ${op.path} no longer exists`\n\t\t);\n\t\tlogger.error(e);\n\t}\n\n\trelease();\n}\n"],"names":["journalFSEvents","php","fsRoot","onEntry","bindToCurrentRuntime","normalizePath","FS","__private__dont__use","FSHooks","createFSHooks","entry","op","recordExistingPath","originalFunctions","name","bind","hook","args","unbind","fn","unbindFromOldRuntime","recordEntry","stream","path","node","mode","old_path","new_path","oldLookup","newParentPath","joinPaths","basename","replayFSJournal","entries","fromPath","toPath","file","normalizeFilesystemOperations","journal","substitutions","i","j","formerType","checkRelationship","latter","former","logger","updated","index","latterPath","latterIsDir","formerIsDir","formerPath","hydrateUpdateFileOps","updates","hydrateOp","hydrateLock","Semaphore","release","e"],"mappings":"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"}