{"version":3,"file":"index.js","sources":["../../../../packages/playground/storage/src/lib/github.ts","../../../../packages/playground/storage/src/lib/changeset.ts","../../../../packages/playground/storage/src/lib/browser-fs.ts","../../../../isomorphic-git/src/utils/fromValue.js","../../../../isomorphic-git/src/utils/getIterator.js","../../../../isomorphic-git/src/utils/StreamReader.js","../../../../isomorphic-git/src/utils/padHex.js","../../../../isomorphic-git/src/models/GitPktLine.js","../../../../isomorphic-git/src/errors/BaseError.js","../../../../isomorphic-git/src/errors/InternalError.js","../../../../isomorphic-git/src/errors/UnsafeFilepathError.js","../../../../isomorphic-git/src/utils/compareStrings.js","../../../../isomorphic-git/src/utils/comparePath.js","../../../../isomorphic-git/src/utils/compareTreeEntryPath.js","../../../../isomorphic-git/src/models/GitTree.js","../../../../isomorphic-git/src/utils/formatAuthor.js","../../../../isomorphic-git/src/utils/normalizeNewlines.js","../../../../isomorphic-git/src/utils/parseAuthor.js","../../../../isomorphic-git/src/models/GitAnnotatedTag.js","../../../../isomorphic-git/src/utils/indent.js","../../../../isomorphic-git/src/utils/outdent.js","../../../../isomorphic-git/src/models/GitCommit.js","../../../../isomorphic-git/src/models/GitObject.js","../../../../isomorphic-git/src/utils/BufferCursor.js","../../../../isomorphic-git/src/utils/applyDelta.js","../../../../isomorphic-git/src/utils/git-list-pack.js","../../../../isomorphic-git/src/utils/inflate.js","../../../../node_modules/inherits/inherits_browser.js","../../../../node_modules/base64-js/index.js","../../../../node_modules/ieee754/index.js","../../../../node_modules/buffer/index.js","../../../../node_modules/safe-buffer/index.js","../../../../node_modules/sha.js/hash.js","../../../../node_modules/sha.js/sha1.js","../../../../isomorphic-git/src/utils/toHex.js","../../../../isomorphic-git/src/utils/shasum.js","../../../../isomorphic-git/src/models/GitPackIndex.js","../../../../isomorphic-git/src/errors/InvalidOidError.js","../../../../isomorphic-git/src/errors/ObjectTypeError.js","../../../../isomorphic-git/src/utils/forAwait.js","../../../../isomorphic-git/src/utils/collect.js","../../../../isomorphic-git/src/utils/FIFO.js","../../../../isomorphic-git/src/models/GitSideBand.js","../../../../isomorphic-git/src/wire/parseUploadPackResponse.js","../../../../packages/playground/storage/src/lib/git-sparse-checkout.ts","../../../../packages/playground/storage/src/lib/paths.ts"],"sourcesContent":["import { Semaphore } from '@php-wasm/util';\nimport { Octokit } from 'octokit';\nimport { Changeset } from './changeset';\n\nexport type GithubClient = ReturnType<typeof createClient>;\n\nexport function createClient(githubToken: string): Octokit {\n\tconst octokit = new Octokit({\n\t\tauth: githubToken,\n\t});\n\treturn octokit;\n}\n\nexport type Files = Record<string, Uint8Array>;\nexport function filesListToObject(files: any[], root = '') {\n\tif (root.length && !root.endsWith('/')) {\n\t\troot += '/';\n\t}\n\tconst result: Files = {};\n\tfor (const file of files) {\n\t\tif (file.path.startsWith(root)) {\n\t\t\tresult[file.path.substring(root.length)] = file.content;\n\t\t}\n\t}\n\treturn result;\n}\n\nexport interface GetFilesProgress {\n\tfoundFiles: number;\n\tdownloadedFiles: number;\n}\nexport interface GetFilesOptions {\n\tonProgress?: ({ foundFiles, downloadedFiles }: GetFilesProgress) => void;\n\tprogress?: GetFilesProgress;\n}\nexport async function getFilesFromDirectory(\n\toctokit: GithubClient,\n\towner: string,\n\trepo: string,\n\tref: string,\n\tpath: string,\n\toptions: GetFilesOptions = {}\n) {\n\tif (!options.progress) {\n\t\toptions.progress = {\n\t\t\tfoundFiles: 0,\n\t\t\tdownloadedFiles: 0,\n\t\t};\n\t}\n\tconst { onProgress } = options;\n\tconst filePromises: Promise<any>[] = [];\n\tconst directoryPromises: Promise<any>[] = [];\n\n\t// Fetch the content of the directory\n\tconst { data: content } = await octokit.rest.repos.getContent({\n\t\towner,\n\t\trepo,\n\t\tpath,\n\t\tref,\n\t});\n\tif (!Array.isArray(content)) {\n\t\tthrow new Error(\n\t\t\t`Expected the list of files to be an array, but got ${typeof content}`\n\t\t);\n\t}\n\n\tfor (const item of content) {\n\t\tif (item.type === 'file') {\n\t\t\t++options.progress.foundFiles;\n\t\t\tonProgress?.(options.progress);\n\t\t\tfilePromises.push(\n\t\t\t\tgetFileContent(octokit, owner, repo, ref, item).then((file) => {\n\t\t\t\t\t++options.progress!.downloadedFiles;\n\t\t\t\t\tonProgress?.(options.progress!);\n\t\t\t\t\treturn file;\n\t\t\t\t})\n\t\t\t);\n\t\t} else if (item.type === 'dir') {\n\t\t\tdirectoryPromises.push(\n\t\t\t\tgetFilesFromDirectory(\n\t\t\t\t\toctokit,\n\t\t\t\t\towner,\n\t\t\t\t\trepo,\n\t\t\t\t\tref,\n\t\t\t\t\titem.path,\n\t\t\t\t\toptions\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tconst files = await Promise.all(filePromises);\n\tconst filesInDirs = (await Promise.all(directoryPromises)).flatMap(\n\t\t(dir) => dir\n\t);\n\treturn [...files, ...filesInDirs];\n}\n\nconst semaphore = new Semaphore({ concurrency: 15 });\nasync function getFileContent(\n\toctokit: GithubClient,\n\towner: string,\n\trepo: string,\n\tref: string,\n\titem: { path: string; name: string }\n) {\n\tconst release = await semaphore.acquire();\n\ttry {\n\t\tconst { data: fileContent } = await octokit.rest.repos.getContent({\n\t\t\towner,\n\t\t\trepo,\n\t\t\tref,\n\t\t\tpath: item.path,\n\t\t});\n\t\tif (!('content' in fileContent)) {\n\t\t\tthrow new Error(`No content found for ${item.path}`);\n\t\t}\n\t\treturn {\n\t\t\tname: item.name,\n\t\t\tpath: item.path,\n\t\t\tcontent: base64ToUint8Array(fileContent.content),\n\t\t};\n\t} finally {\n\t\trelease();\n\t}\n}\n\nfunction base64ToUint8Array(base64: string) {\n\tconst binaryString = window.atob(base64); // This will convert base64 to binary string\n\tconst len = binaryString.length;\n\tconst bytes = new Uint8Array(len);\n\tfor (let i = 0; i < len; i++) {\n\t\tbytes[i] = binaryString.charCodeAt(i);\n\t}\n\treturn bytes;\n}\n\n/**\n * Usage:\n * > await getArtifact('wordpress', 'wordpress-develop', 5511, 'build.yml')\n *\n * To get the first artifact produced by the \"build.yml\" workflow running\n * as a part of the PR 5511\n *\n * @returns\n */\nexport async function getArtifact(\n\toctokit: GithubClient,\n\towner: string,\n\trepo: string,\n\tpull_number: number,\n\tworkflow_id: string\n) {\n\tconst { data: pullRequest } = await octokit.rest.pulls.get({\n\t\towner,\n\t\trepo,\n\t\tpull_number,\n\t});\n\tconst workflowRuns = await octokit.rest.actions.listWorkflowRuns({\n\t\towner,\n\t\trepo,\n\t\tbranch: pullRequest.head.ref,\n\t\tworkflow_id,\n\t});\n\tconst runId = workflowRuns.data.workflow_runs[0]?.id;\n\tconst artifacts = await octokit.rest.actions.listWorkflowRunArtifacts({\n\t\towner,\n\t\trepo,\n\t\trun_id: runId,\n\t});\n\n\tconst artifact = await octokit.rest.actions.downloadArtifact({\n\t\towner,\n\t\trepo,\n\t\tartifact_id: artifacts.data.artifacts[0].id,\n\t\tarchive_format: 'zip',\n\t});\n\treturn artifact.data;\n}\n\nexport async function mayPush(octokit: Octokit, owner: string, repo: string) {\n\tconst { data: repository, headers } = await octokit.request(\n\t\t'GET /repos/{owner}/{repo}',\n\t\t{\n\t\t\towner,\n\t\t\trepo,\n\t\t}\n\t);\n\tif (!headers['x-oauth-scopes'] || !repository.permissions?.push) {\n\t\treturn false;\n\t}\n\n\t// @TODO Find a way to bubble up the following error earlier than on the\n\t//       first push attempt:\n\t//       \"organization has enabled OAuth App access restrictions\"\n\treturn true;\n}\n\nexport async function createOrUpdateBranch(\n\toctokit: Octokit,\n\towner: string,\n\trepo: string,\n\tbranch: string,\n\tnewHead: string\n) {\n\tconst branchExists = await octokit\n\t\t.request('GET /repos/{owner}/{repo}/branches/{branch}', {\n\t\t\towner,\n\t\t\trepo,\n\t\t\tbranch,\n\t\t})\n\t\t.then(\n\t\t\t() => true,\n\t\t\t() => false\n\t\t);\n\n\tif (branchExists) {\n\t\tawait octokit.request('PATCH /repos/{owner}/{repo}/git/refs/{ref}', {\n\t\t\towner,\n\t\t\trepo,\n\t\t\tsha: newHead,\n\t\t\tref: `heads/${branch}`,\n\t\t});\n\t} else {\n\t\tawait octokit.request('POST /repos/{owner}/{repo}/git/refs', {\n\t\t\towner,\n\t\t\trepo,\n\t\t\tsha: newHead,\n\t\t\tref: `refs/heads/${branch}`,\n\t\t});\n\t}\n}\n\n/**\n * @param octokit\n * @param owner\n * @param repo\n * @returns The owner of the forked repository\n */\nexport async function fork(octokit: Octokit, owner: string, repo: string) {\n\tconst user = await octokit.request('GET /user');\n\tconst forks = await octokit.request('GET /repos/{owner}/{repo}/forks', {\n\t\towner,\n\t\trepo,\n\t});\n\tconst hasFork = forks.data.find(\n\t\t(fork: any) => fork.owner && fork.owner.login === user.data.login\n\t);\n\n\tif (!hasFork) {\n\t\tawait octokit.request('POST /repos/{owner}/{repo}/forks', {\n\t\t\towner,\n\t\t\trepo,\n\t\t});\n\t}\n\n\treturn user.data.login;\n}\n\nexport async function createCommit(\n\toctokit: Octokit,\n\towner: string,\n\trepo: string,\n\tmessage: string,\n\tparentSha: string,\n\ttreeSha: string\n): Promise<string> {\n\tconst {\n\t\tdata: { sha },\n\t} = await octokit.request('POST /repos/{owner}/{repo}/git/commits', {\n\t\towner,\n\t\trepo,\n\t\tmessage,\n\t\ttree: treeSha,\n\t\tparents: [parentSha],\n\t});\n\n\treturn sha;\n}\n\nexport async function createTree(\n\toctokit: Octokit,\n\towner: string,\n\trepo: string,\n\tparentSha: string,\n\tchangeset: Changeset\n) {\n\tconst tree = await createTreeNodes(\n\t\toctokit,\n\t\towner,\n\t\trepo,\n\t\tparentSha,\n\t\tchangeset\n\t);\n\tif (tree.length === 0) {\n\t\treturn null;\n\t}\n\n\tconst {\n\t\tdata: { sha: newTreeSha },\n\t} = await octokit.request('POST /repos/{owner}/{repo}/git/trees', {\n\t\towner,\n\t\trepo,\n\t\tbase_tree: parentSha,\n\t\ttree,\n\t});\n\treturn newTreeSha;\n}\n\nexport type GitHubTreeNode = {\n\tpath: string;\n\tmode: '100644';\n} & (\n\t| {\n\t\t\tsha: string | null;\n\t  }\n\t| {\n\t\t\tcontent: string;\n\t  }\n);\nexport async function createTreeNodes(\n\toctokit: Octokit,\n\towner: string,\n\trepo: string,\n\tparentSha: string,\n\tchangeset: Changeset\n): Promise<GitHubTreeNode[]> {\n\tconst blobsPromises = [];\n\tfor (const [path, content] of changeset.create) {\n\t\tblobsPromises.push(createTreeNode(octokit, owner, repo, path, content));\n\t}\n\tfor (const [path, content] of changeset.update) {\n\t\tblobsPromises.push(createTreeNode(octokit, owner, repo, path, content));\n\t}\n\tfor (const path of changeset.delete) {\n\t\tblobsPromises.push(deleteFile(octokit, owner, repo, parentSha, path));\n\t}\n\treturn Promise.all(blobsPromises).then(\n\t\t(blobs) => blobs.filter((blob) => !!blob) as GitHubTreeNode[]\n\t);\n}\n\nconst blobSemaphore = new Semaphore({ concurrency: 10 });\nexport async function createTreeNode(\n\toctokit: Octokit,\n\towner: string,\n\trepo: string,\n\tpath: string,\n\tcontent: string | Uint8Array\n): Promise<GitHubTreeNode> {\n\tconst release = await blobSemaphore.acquire();\n\ttry {\n\t\tif (ArrayBuffer.isView(content)) {\n\t\t\ttry {\n\t\t\t\t// Attempt to decode the byteArray as a UTF-8 string\n\t\t\t\tconst stringContent = new TextDecoder('utf-8', {\n\t\t\t\t\tfatal: true,\n\t\t\t\t}).decode(content);\n\t\t\t\treturn {\n\t\t\t\t\tpath,\n\t\t\t\t\tcontent: stringContent,\n\t\t\t\t\tmode: '100644',\n\t\t\t\t};\n\t\t\t} catch (e) {\n\t\t\t\t// If an error occurs, the byteArray is not valid UTF-8 and we must\n\t\t\t\t// create a blob first\n\t\t\t\tconst {\n\t\t\t\t\tdata: { sha },\n\t\t\t\t} = await octokit.rest.git.createBlob({\n\t\t\t\t\towner,\n\t\t\t\t\trepo,\n\t\t\t\t\tencoding: 'base64',\n\t\t\t\t\tcontent: uint8ArrayToBase64(content),\n\t\t\t\t});\n\t\t\t\treturn {\n\t\t\t\t\tpath,\n\t\t\t\t\tsha,\n\t\t\t\t\tmode: '100644',\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\t// Content is a string\n\t\t\treturn {\n\t\t\t\tpath,\n\t\t\t\tcontent,\n\t\t\t\tmode: '100644',\n\t\t\t};\n\t\t}\n\t} finally {\n\t\trelease();\n\t}\n}\n\nexport async function deleteFile(\n\toctokit: Octokit,\n\towner: string,\n\trepo: string,\n\tparentSha: string,\n\tpath: string\n): Promise<GitHubTreeNode | undefined> {\n\tconst release = await blobSemaphore.acquire();\n\ttry {\n\t\t// Deleting a non-existent file from a tree leads to an\n\t\t// \"GitRPC::BadObjectState\" error, so we only attempt to delete the file if\n\t\t// it exists.\n\t\tawait octokit.request('HEAD /repos/{owner}/{repo}/contents/:path', {\n\t\t\towner,\n\t\t\trepo,\n\t\t\tref: parentSha,\n\t\t\tpath,\n\t\t});\n\n\t\treturn {\n\t\t\tpath,\n\t\t\tmode: '100644',\n\t\t\tsha: null,\n\t\t};\n\t} catch (error) {\n\t\t// Pass\n\t\treturn undefined;\n\t} finally {\n\t\trelease();\n\t}\n}\n\nfunction uint8ArrayToBase64(bytes: Uint8Array) {\n\tconst binary = [];\n\tconst len = bytes.byteLength;\n\tfor (let i = 0; i < len; i++) {\n\t\tbinary.push(String.fromCharCode(bytes[i]));\n\t}\n\treturn window.btoa(binary.join(''));\n}\n","import { UniversalPHP } from '@php-wasm/universal';\nimport { joinPaths, normalizePath } from '@php-wasm/util';\n\nexport type IterateFilesOptions = {\n\t/**\n\t * Should yield paths relative to the root directory?\n\t * If false, all paths will be absolute.\n\t */\n\trelativePaths?: boolean;\n\n\t/**\n\t * The root directory that Playground paths start from.\n\t */\n\tplaygroundRoot?: string;\n\n\t/**\n\t * A prefix to add to all paths.\n\t * Only used if `relativePaths` is true.\n\t */\n\tpathPrefix?: string;\n\n\t/**\n\t * A list of paths to exclude from the results.\n\t */\n\texceptPaths?: string[];\n};\n\n/**\n * Iterates over all files in a Playground directory and its subdirectories.\n *\n * @param playground - The Playground/PHP instance.\n * @param root - The root directory to start iterating from.\n * @param options - Optional configuration.\n * @returns All files found in the tree.\n */\nexport async function* iterateFiles(\n\tplayground: UniversalPHP,\n\troot: string,\n\t{ exceptPaths = [] }: IterateFilesOptions = {}\n): AsyncGenerator<FileEntry> {\n\troot = normalizePath(root);\n\t// If the root is be a file, not a directory, then\n\t// just yield it and return immediately.\n\tif (!(await playground.isDir(root))) {\n\t\tif (await playground.fileExists(root)) {\n\t\t\tyield {\n\t\t\t\tpath: root,\n\t\t\t\tread: async () => await playground.readFileAsBuffer(root),\n\t\t\t};\n\t\t}\n\t\treturn;\n\t}\n\n\tconst stack: string[] = [root];\n\twhile (stack.length) {\n\t\tconst currentParent = stack.pop();\n\t\tif (!currentParent) {\n\t\t\treturn;\n\t\t}\n\t\tconst files = await playground.listFiles(currentParent);\n\t\tfor (const file of files) {\n\t\t\tconst absPath = joinPaths(currentParent, file);\n\t\t\tif (exceptPaths.includes(absPath.substring(root.length + 1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (await playground.isDir(absPath)) {\n\t\t\t\tstack.push(absPath);\n\t\t\t} else {\n\t\t\t\tyield {\n\t\t\t\t\tpath: absPath,\n\t\t\t\t\tread: async () =>\n\t\t\t\t\t\tawait playground.readFileAsBuffer(absPath),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport type FileEntry = {\n\tpath: string;\n\tread: () => Promise<Uint8Array>;\n};\n\n/**\n * Represents a set of changes to be applied to a data store.\n */\nexport type Changeset = {\n\t/**\n\t * Created files.\n\t */\n\tcreate: Map<string, Uint8Array>;\n\n\t/**\n\t * Updated files.\n\t */\n\tupdate: Map<string, Uint8Array>;\n\n\t/**\n\t * Deleted files.\n\t */\n\tdelete: Set<string>;\n};\n\n/**\n * Compares two sets of files and returns a changeset object that describes\n * the differences between them.\n *\n * @param filesBefore - A map of file paths to Uint8Array objects representing the contents\n *                      of the files before the changes.\n * @param filesAfter - An async generator that yields FileEntry objects representing the files\n *                     after the changes.\n * @returns A changeset object that describes the differences between the two sets of files.\n */\nexport async function changeset(\n\tfilesBefore: Map<string, Uint8Array>,\n\tfilesAfter: AsyncGenerator<FileEntry> | Iterable<FileEntry>\n) {\n\tconst changes: Changeset = {\n\t\tcreate: new Map(),\n\t\tupdate: new Map(),\n\t\tdelete: new Set(),\n\t};\n\n\tconst seenFilesAfter = new Set<string>();\n\tfor await (const fileAfter of filesAfter) {\n\t\tseenFilesAfter.add(fileAfter.path);\n\n\t\tconst before = filesBefore.get(fileAfter.path);\n\t\tconst after = await fileAfter.read();\n\t\tif (before) {\n\t\t\tif (!uint8arraysEqual(before, after)) {\n\t\t\t\tchanges.update.set(fileAfter.path, after);\n\t\t\t}\n\t\t} else {\n\t\t\tchanges.create.set(fileAfter.path, after);\n\t\t}\n\t}\n\n\tfor (const pathBefore of filesBefore.keys()) {\n\t\tif (!seenFilesAfter.has(pathBefore)) {\n\t\t\tchanges.delete.add(pathBefore);\n\t\t}\n\t}\n\n\treturn changes;\n}\n\nfunction uint8arraysEqual(a: Uint8Array, b: Uint8Array): boolean {\n\treturn a.length === b.length && a.every((val, index) => val === b[index]);\n}\n","import type { MountDevice } from '@php-wasm/web';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type * as pleaseLoadTypes from 'wicg-file-system-access';\n\nexport async function directoryHandleFromMountDevice(\n\tdevice: MountDevice\n): Promise<FileSystemDirectoryHandle> {\n\tif (device.type === 'local-fs') {\n\t\treturn device.handle;\n\t}\n\n\treturn opfsPathToDirectoryHandle(device.path);\n}\n\nexport async function opfsPathToDirectoryHandle(\n\topfsPath: string\n): Promise<FileSystemDirectoryHandle> {\n\tconst parts = opfsPath.split('/').filter((p) => p.length > 0);\n\tlet handle = await navigator.storage.getDirectory();\n\tfor (const part of parts) {\n\t\thandle = await handle.getDirectoryHandle(part, { create: true });\n\t}\n\treturn handle;\n}\n\nexport async function directoryHandleToOpfsPath(\n\tdirectoryHandle: FileSystemDirectoryHandle\n): Promise<string> {\n\tconst root = await navigator.storage.getDirectory();\n\tconst pathParts = await root.resolve(directoryHandle);\n\tif (pathParts === null) {\n\t\tthrow new DOMException(\n\t\t\t'Unable to resolve path of OPFS directory handle.',\n\t\t\t'NotFoundError'\n\t\t);\n\t}\n\treturn '/' + pathParts.join('/');\n}\n\nexport async function clearContentsFromMountDevice(mountDevice: MountDevice) {\n\tconst parentHandle = await directoryHandleFromMountDevice(mountDevice);\n\tfor await (const name of parentHandle.keys()) {\n\t\tawait parentHandle.removeEntry(name, {\n\t\t\trecursive: true,\n\t\t});\n\t}\n}\n","// Convert a value to an Async Iterator\n// This will be easier with async generator functions.\nexport function fromValue(value) {\n  let queue = [value]\n  return {\n    next() {\n      return Promise.resolve({ done: queue.length === 0, value: queue.pop() })\n    },\n    return() {\n      queue = []\n      return {}\n    },\n    [Symbol.asyncIterator]() {\n      return this\n    },\n  }\n}\n","import { fromValue } from '../utils/fromValue.js'\n\nexport function getIterator(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return iterable[Symbol.asyncIterator]()\n  }\n  if (iterable[Symbol.iterator]) {\n    return iterable[Symbol.iterator]()\n  }\n  if (iterable.next) {\n    return iterable\n  }\n  return fromValue(iterable)\n}\n","import { getIterator } from './getIterator.js'\n\n// inspired by 'gartal' but lighter-weight and more battle-tested.\nexport class StreamReader {\n  constructor(stream) {\n    // TODO: fix usage in bundlers before Buffer dependency is removed #1855\n    if (typeof Buffer === 'undefined') {\n      throw new Error('Missing Buffer dependency')\n    }\n    this.stream = getIterator(stream)\n    this.buffer = null\n    this.cursor = 0\n    this.undoCursor = 0\n    this.started = false\n    this._ended = false\n    this._discardedBytes = 0\n  }\n\n  eof() {\n    return this._ended && this.cursor === this.buffer.length\n  }\n\n  tell() {\n    return this._discardedBytes + this.cursor\n  }\n\n  async byte() {\n    if (this.eof()) return\n    if (!this.started) await this._init()\n    if (this.cursor === this.buffer.length) {\n      await this._loadnext()\n      if (this._ended) return\n    }\n    this._moveCursor(1)\n    return this.buffer[this.undoCursor]\n  }\n\n  async chunk() {\n    if (this.eof()) return\n    if (!this.started) await this._init()\n    if (this.cursor === this.buffer.length) {\n      await this._loadnext()\n      if (this._ended) return\n    }\n    this._moveCursor(this.buffer.length)\n    return this.buffer.slice(this.undoCursor, this.cursor)\n  }\n\n  async read(n) {\n    if (this.eof()) return\n    if (!this.started) await this._init()\n    if (this.cursor + n > this.buffer.length) {\n      this._trim()\n      await this._accumulate(n)\n    }\n    this._moveCursor(n)\n    return this.buffer.slice(this.undoCursor, this.cursor)\n  }\n\n  async skip(n) {\n    if (this.eof()) return\n    if (!this.started) await this._init()\n    if (this.cursor + n > this.buffer.length) {\n      this._trim()\n      await this._accumulate(n)\n    }\n    this._moveCursor(n)\n  }\n\n  async undo() {\n    this.cursor = this.undoCursor\n  }\n\n  async _next() {\n    this.started = true\n    let { done, value } = await this.stream.next()\n    if (done) {\n      this._ended = true\n      if (!value) return Buffer.alloc(0)\n    }\n    if (value) {\n      value = Buffer.from(value)\n    }\n    return value\n  }\n\n  _trim() {\n    // Throw away parts of the buffer we don't need anymore\n    // assert(this.cursor <= this.buffer.length)\n    this.buffer = this.buffer.slice(this.undoCursor)\n    this.cursor -= this.undoCursor\n    this._discardedBytes += this.undoCursor\n    this.undoCursor = 0\n  }\n\n  _moveCursor(n) {\n    this.undoCursor = this.cursor\n    this.cursor += n\n    if (this.cursor > this.buffer.length) {\n      this.cursor = this.buffer.length\n    }\n  }\n\n  async _accumulate(n) {\n    if (this._ended) return\n    // Expand the buffer until we have N bytes of data\n    // or we've reached the end of the stream\n    const buffers = [this.buffer]\n    while (this.cursor + n > lengthBuffers(buffers)) {\n      const nextbuffer = await this._next()\n      if (this._ended) break\n      buffers.push(nextbuffer)\n    }\n    this.buffer = Buffer.concat(buffers)\n  }\n\n  async _loadnext() {\n    this._discardedBytes += this.buffer.length\n    this.undoCursor = 0\n    this.cursor = 0\n    this.buffer = await this._next()\n  }\n\n  async _init() {\n    this.buffer = await this._next()\n  }\n}\n\n// This helper function helps us postpone concatenating buffers, which\n// would create intermediate buffer objects,\nfunction lengthBuffers(buffers) {\n  return buffers.reduce((acc, buffer) => acc + buffer.length, 0)\n}\n","export function padHex(b, n) {\n  const s = n.toString(16)\n  return '0'.repeat(b - s.length) + s\n}\n","/**\npkt-line Format\n---------------\n\nMuch (but not all) of the payload is described around pkt-lines.\n\nA pkt-line is a variable length binary string.  The first four bytes\nof the line, the pkt-len, indicates the total length of the line,\nin hexadecimal.  The pkt-len includes the 4 bytes used to contain\nthe length's hexadecimal representation.\n\nA pkt-line MAY contain binary data, so implementers MUST ensure\npkt-line parsing/formatting routines are 8-bit clean.\n\nA non-binary line SHOULD BE terminated by an LF, which if present\nMUST be included in the total length. Receivers MUST treat pkt-lines\nwith non-binary data the same whether or not they contain the trailing\nLF (stripping the LF if present, and not complaining when it is\nmissing).\n\nThe maximum length of a pkt-line's data component is 65516 bytes.\nImplementations MUST NOT send pkt-line whose length exceeds 65520\n(65516 bytes of payload + 4 bytes of length data).\n\nImplementations SHOULD NOT send an empty pkt-line (\"0004\").\n\nA pkt-line with a length field of 0 (\"0000\"), called a flush-pkt,\nis a special case and MUST be handled differently than an empty\npkt-line (\"0004\").\n\n----\n  pkt-line     =  data-pkt / flush-pkt\n\n  data-pkt     =  pkt-len pkt-payload\n  pkt-len      =  4*(HEXDIG)\n  pkt-payload  =  (pkt-len - 4)*(OCTET)\n\n  flush-pkt    = \"0000\"\n----\n\nExamples (as C-style strings):\n\n----\n  pkt-line          actual value\n  ---------------------------------\n  \"0006a\\n\"         \"a\\n\"\n  \"0005a\"           \"a\"\n  \"000bfoobar\\n\"    \"foobar\\n\"\n  \"0004\"            \"\"\n----\n*/\nimport { StreamReader } from '../utils/StreamReader.js'\nimport { padHex } from '../utils/padHex.js'\n\n// I'm really using this more as a namespace.\n// There's not a lot of \"state\" in a pkt-line\n\nexport class GitPktLine {\n  static flush() {\n    return Buffer.from('0000', 'utf8')\n  }\n\n  static delim() {\n    return Buffer.from('0001', 'utf8')\n  }\n\n  static encode(line) {\n    if (typeof line === 'string') {\n      line = Buffer.from(line)\n    }\n    const length = line.length + 4\n    const hexlength = padHex(4, length)\n    return Buffer.concat([Buffer.from(hexlength, 'utf8'), line])\n  }\n\n  static streamReader(stream) {\n    const reader = new StreamReader(stream)\n    return async function read() {\n      try {\n        let length = await reader.read(4)\n        if (length == null) return true\n        length = parseInt(length.toString('utf8'), 16)\n        if (length === 0) return null\n        if (length === 1) return null // delim packets\n        const buffer = await reader.read(length - 4)\n        if (buffer == null) return true\n        return buffer\n      } catch (err) {\n        stream.error = err\n        return true\n      }\n    }\n  }\n}\n","export class BaseError extends Error {\n  constructor(message) {\n    super(message)\n    // Setting this here allows TS to infer that all git errors have a `caller` property and\n    // that its type is string.\n    this.caller = ''\n  }\n\n  toJSON() {\n    // Error objects aren't normally serializable. So we do something about that.\n    return {\n      code: this.code,\n      data: this.data,\n      caller: this.caller,\n      message: this.message,\n      stack: this.stack,\n    }\n  }\n\n  fromJSON(json) {\n    const e = new BaseError(json.message)\n    e.code = json.code\n    e.data = json.data\n    e.caller = json.caller\n    e.stack = json.stack\n    return e\n  }\n\n  get isIsomorphicGitError() {\n    return true\n  }\n}\n","import { BaseError } from './BaseError.js'\n\nexport class InternalError extends BaseError {\n  /**\n   * @param {string} message\n   */\n  constructor(message) {\n    super(\n      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`\n    )\n    this.code = this.name = InternalError.code\n    this.data = { message }\n  }\n}\n/** @type {'InternalError'} */\nInternalError.code = 'InternalError'\n","import { BaseError } from './BaseError.js'\n\nexport class UnsafeFilepathError extends BaseError {\n  /**\n   * @param {string} filepath\n   */\n  constructor(filepath) {\n    super(`The filepath \"${filepath}\" contains unsafe character sequences`)\n    this.code = this.name = UnsafeFilepathError.code\n    this.data = { filepath }\n  }\n}\n/** @type {'UnsafeFilepathError'} */\nUnsafeFilepathError.code = 'UnsafeFilepathError'\n","export function compareStrings(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return -(a < b) || +(a > b)\n}\n","import { compareStrings } from './compareStrings'\n\nexport function comparePath(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return compareStrings(a.path, b.path)\n}\n","import { compareStrings } from './compareStrings'\n\nexport function compareTreeEntryPath(a, b) {\n  // Git sorts tree entries as if there is a trailing slash on directory names.\n  return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b))\n}\n\nfunction appendSlashIfDir(entry) {\n  return entry.mode === '040000' ? entry.path + '/' : entry.path\n}\n","import { InternalError } from '../errors/InternalError.js'\nimport { UnsafeFilepathError } from '../errors/UnsafeFilepathError.js'\nimport { comparePath } from '../utils/comparePath.js'\nimport { compareTreeEntryPath } from '../utils/compareTreeEntryPath.js'\n\n/**\n *\n * @typedef {Object} TreeEntry\n * @property {string} mode - the 6 digit hexadecimal mode\n * @property {string} path - the name of the file or directory\n * @property {string} oid - the SHA-1 object id of the blob or tree\n * @property {'commit'|'blob'|'tree'} type - the type of object\n */\n\nfunction mode2type(mode) {\n  // prettier-ignore\n  switch (mode) {\n    case '040000': return 'tree'\n    case '100644': return 'blob'\n    case '100755': return 'blob'\n    case '120000': return 'blob'\n    case '160000': return 'commit'\n  }\n  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`)\n}\n\nfunction parseBuffer(buffer) {\n  const _entries = []\n  let cursor = 0\n  while (cursor < buffer.length) {\n    const space = buffer.indexOf(32, cursor)\n    if (space === -1) {\n      throw new InternalError(\n        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`\n      )\n    }\n    const nullchar = buffer.indexOf(0, cursor)\n    if (nullchar === -1) {\n      throw new InternalError(\n        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`\n      )\n    }\n    let mode = buffer.slice(cursor, space).toString('utf8')\n    if (mode === '40000') mode = '040000' // makes it line up neater in printed output\n    const type = mode2type(mode)\n    const path = buffer.slice(space + 1, nullchar).toString('utf8')\n\n    // Prevent malicious git repos from writing to \"..\\foo\" on clone etc\n    if (path.includes('\\\\') || path.includes('/')) {\n      throw new UnsafeFilepathError(path)\n    }\n\n    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex')\n    cursor = nullchar + 21\n    _entries.push({ mode, path, oid, type })\n  }\n  return _entries\n}\n\nfunction limitModeToAllowed(mode) {\n  if (typeof mode === 'number') {\n    mode = mode.toString(8)\n  }\n  // tree\n  if (mode.match(/^0?4.*/)) return '040000' // Directory\n  if (mode.match(/^1006.*/)) return '100644' // Regular non-executable file\n  if (mode.match(/^1007.*/)) return '100755' // Regular executable file\n  if (mode.match(/^120.*/)) return '120000' // Symbolic link\n  if (mode.match(/^160.*/)) return '160000' // Commit (git submodule reference)\n  throw new InternalError(`Could not understand file mode: ${mode}`)\n}\n\nfunction nudgeIntoShape(entry) {\n  if (!entry.oid && entry.sha) {\n    entry.oid = entry.sha // Github\n  }\n  entry.mode = limitModeToAllowed(entry.mode) // index\n  if (!entry.type) {\n    entry.type = mode2type(entry.mode) // index\n  }\n  return entry\n}\n\nexport class GitTree {\n  constructor(entries) {\n    if (Buffer.isBuffer(entries)) {\n      this._entries = parseBuffer(entries)\n    } else if (Array.isArray(entries)) {\n      this._entries = entries.map(nudgeIntoShape)\n    } else {\n      throw new InternalError('invalid type passed to GitTree constructor')\n    }\n    // Tree entries are not sorted alphabetically in the usual sense (see `compareTreeEntryPath`)\n    // but it is important later on that these be sorted in the same order as they would be returned from readdir.\n    this._entries.sort(comparePath)\n  }\n\n  static from(tree) {\n    return new GitTree(tree)\n  }\n\n  render() {\n    return this._entries\n      .map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`)\n      .join('\\n')\n  }\n\n  toObject() {\n    // Adjust the sort order to match git's\n    const entries = [...this._entries]\n    entries.sort(compareTreeEntryPath)\n    return Buffer.concat(\n      entries.map(entry => {\n        const mode = Buffer.from(entry.mode.replace(/^0/, ''))\n        const space = Buffer.from(' ')\n        const path = Buffer.from(entry.path, 'utf8')\n        const nullchar = Buffer.from([0])\n        const oid = Buffer.from(entry.oid, 'hex')\n        return Buffer.concat([mode, space, path, nullchar, oid])\n      })\n    )\n  }\n\n  /**\n   * @returns {TreeEntry[]}\n   */\n  entries() {\n    return this._entries\n  }\n\n  *[Symbol.iterator]() {\n    for (const entry of this._entries) {\n      yield entry\n    }\n  }\n}\n","export function formatAuthor({ name, email, timestamp, timezoneOffset }) {\n  timezoneOffset = formatTimezoneOffset(timezoneOffset)\n  return `${name} <${email}> ${timestamp} ${timezoneOffset}`\n}\n\n// The amount of effort that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction formatTimezoneOffset(minutes) {\n  const sign = simpleSign(negateExceptForZero(minutes))\n  minutes = Math.abs(minutes)\n  const hours = Math.floor(minutes / 60)\n  minutes -= hours * 60\n  let strHours = String(hours)\n  let strMinutes = String(minutes)\n  if (strHours.length < 2) strHours = '0' + strHours\n  if (strMinutes.length < 2) strMinutes = '0' + strMinutes\n  return (sign === -1 ? '-' : '+') + strHours + strMinutes\n}\n\nfunction simpleSign(n) {\n  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1)\n}\n\nfunction negateExceptForZero(n) {\n  return n === 0 ? n : -n\n}\n","export function normalizeNewlines(str) {\n  // remove all <CR>\n  str = str.replace(/\\r/g, '')\n  // no extra newlines up front\n  str = str.replace(/^\\n+/, '')\n  // and a single newline at the end\n  str = str.replace(/\\n+$/, '') + '\\n'\n  return str\n}\n","export function parseAuthor(author) {\n  const [, name, email, timestamp, offset] = author.match(\n    /^(.*) <(.*)> (.*) (.*)$/\n  )\n  return {\n    name: name,\n    email: email,\n    timestamp: Number(timestamp),\n    timezoneOffset: parseTimezoneOffset(offset),\n  }\n}\n\n// The amount of effort that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction parseTimezoneOffset(offset) {\n  let [, sign, hours, minutes] = offset.match(/(\\+|-)(\\d\\d)(\\d\\d)/)\n  minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes))\n  return negateExceptForZero(minutes)\n}\n\nfunction negateExceptForZero(n) {\n  return n === 0 ? n : -n\n}\n","import { InternalError } from '../errors/InternalError.js'\nimport { formatAuthor } from '../utils/formatAuthor.js'\nimport { normalizeNewlines } from '../utils/normalizeNewlines.js'\nimport { parseAuthor } from '../utils/parseAuthor.js'\n\nexport class GitAnnotatedTag {\n  constructor(tag) {\n    if (typeof tag === 'string') {\n      this._tag = tag\n    } else if (Buffer.isBuffer(tag)) {\n      this._tag = tag.toString('utf8')\n    } else if (typeof tag === 'object') {\n      this._tag = GitAnnotatedTag.render(tag)\n    } else {\n      throw new InternalError(\n        'invalid type passed to GitAnnotatedTag constructor'\n      )\n    }\n  }\n\n  static from(tag) {\n    return new GitAnnotatedTag(tag)\n  }\n\n  static render(obj) {\n    return `object ${obj.object}\ntype ${obj.type}\ntag ${obj.tag}\ntagger ${formatAuthor(obj.tagger)}\n\n${obj.message}\n${obj.gpgsig ? obj.gpgsig : ''}`\n  }\n\n  justHeaders() {\n    return this._tag.slice(0, this._tag.indexOf('\\n\\n'))\n  }\n\n  message() {\n    const tag = this.withoutSignature()\n    return tag.slice(tag.indexOf('\\n\\n') + 2)\n  }\n\n  parse() {\n    return Object.assign(this.headers(), {\n      message: this.message(),\n      gpgsig: this.gpgsig(),\n    })\n  }\n\n  render() {\n    return this._tag\n  }\n\n  headers() {\n    const headers = this.justHeaders().split('\\n')\n    const hs = []\n    for (const h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1)\n      } else {\n        hs.push(h)\n      }\n    }\n    const obj = {}\n    for (const h of hs) {\n      const key = h.slice(0, h.indexOf(' '))\n      const value = h.slice(h.indexOf(' ') + 1)\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value)\n      } else {\n        obj[key] = value\n      }\n    }\n    if (obj.tagger) {\n      obj.tagger = parseAuthor(obj.tagger)\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer)\n    }\n    return obj\n  }\n\n  withoutSignature() {\n    const tag = normalizeNewlines(this._tag)\n    if (tag.indexOf('\\n-----BEGIN PGP SIGNATURE-----') === -1) return tag\n    return tag.slice(0, tag.lastIndexOf('\\n-----BEGIN PGP SIGNATURE-----'))\n  }\n\n  gpgsig() {\n    if (this._tag.indexOf('\\n-----BEGIN PGP SIGNATURE-----') === -1) return\n    const signature = this._tag.slice(\n      this._tag.indexOf('-----BEGIN PGP SIGNATURE-----'),\n      this._tag.indexOf('-----END PGP SIGNATURE-----') +\n        '-----END PGP SIGNATURE-----'.length\n    )\n    return normalizeNewlines(signature)\n  }\n\n  payload() {\n    return this.withoutSignature() + '\\n'\n  }\n\n  toObject() {\n    return Buffer.from(this._tag, 'utf8')\n  }\n\n  static async sign(tag, sign, secretKey) {\n    const payload = tag.payload()\n    let { signature } = await sign({ payload, secretKey })\n    // renormalize the line endings to the one true line-ending\n    signature = normalizeNewlines(signature)\n    const signedTag = payload + signature\n    // return a new tag object\n    return GitAnnotatedTag.from(signedTag)\n  }\n}\n","export function indent(str) {\n  return (\n    str\n      .trim()\n      .split('\\n')\n      .map(x => ' ' + x)\n      .join('\\n') + '\\n'\n  )\n}\n","export function outdent(str) {\n  return str\n    .split('\\n')\n    .map(x => x.replace(/^ /, ''))\n    .join('\\n')\n}\n","import { InternalError } from '../errors/InternalError.js'\nimport { formatAuthor } from '../utils/formatAuthor.js'\nimport { indent } from '../utils/indent.js'\nimport { normalizeNewlines } from '../utils/normalizeNewlines.js'\nimport { outdent } from '../utils/outdent.js'\nimport { parseAuthor } from '../utils/parseAuthor.js'\n\nexport class GitCommit {\n  constructor(commit) {\n    if (typeof commit === 'string') {\n      this._commit = commit\n    } else if (Buffer.isBuffer(commit)) {\n      this._commit = commit.toString('utf8')\n    } else if (typeof commit === 'object') {\n      this._commit = GitCommit.render(commit)\n    } else {\n      throw new InternalError('invalid type passed to GitCommit constructor')\n    }\n  }\n\n  static fromPayloadSignature({ payload, signature }) {\n    const headers = GitCommit.justHeaders(payload)\n    const message = GitCommit.justMessage(payload)\n    const commit = normalizeNewlines(\n      headers + '\\ngpgsig' + indent(signature) + '\\n' + message\n    )\n    return new GitCommit(commit)\n  }\n\n  static from(commit) {\n    return new GitCommit(commit)\n  }\n\n  toObject() {\n    return Buffer.from(this._commit, 'utf8')\n  }\n\n  // Todo: allow setting the headers and message\n  headers() {\n    return this.parseHeaders()\n  }\n\n  // Todo: allow setting the headers and message\n  message() {\n    return GitCommit.justMessage(this._commit)\n  }\n\n  parse() {\n    return Object.assign({ message: this.message() }, this.headers())\n  }\n\n  static justMessage(commit) {\n    return normalizeNewlines(commit.slice(commit.indexOf('\\n\\n') + 2))\n  }\n\n  static justHeaders(commit) {\n    return commit.slice(0, commit.indexOf('\\n\\n'))\n  }\n\n  parseHeaders() {\n    const headers = GitCommit.justHeaders(this._commit).split('\\n')\n    const hs = []\n    for (const h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1)\n      } else {\n        hs.push(h)\n      }\n    }\n    const obj = {\n      parent: [],\n    }\n    for (const h of hs) {\n      const key = h.slice(0, h.indexOf(' '))\n      const value = h.slice(h.indexOf(' ') + 1)\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value)\n      } else {\n        obj[key] = value\n      }\n    }\n    if (obj.author) {\n      obj.author = parseAuthor(obj.author)\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer)\n    }\n    return obj\n  }\n\n  static renderHeaders(obj) {\n    let headers = ''\n    if (obj.tree) {\n      headers += `tree ${obj.tree}\\n`\n    } else {\n      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\\n` // the null tree\n    }\n    if (obj.parent) {\n      if (obj.parent.length === undefined) {\n        throw new InternalError(`commit 'parent' property should be an array`)\n      }\n      for (const p of obj.parent) {\n        headers += `parent ${p}\\n`\n      }\n    }\n    const author = obj.author\n    headers += `author ${formatAuthor(author)}\\n`\n    const committer = obj.committer || obj.author\n    headers += `committer ${formatAuthor(committer)}\\n`\n    if (obj.gpgsig) {\n      headers += 'gpgsig' + indent(obj.gpgsig)\n    }\n    return headers\n  }\n\n  static render(obj) {\n    return GitCommit.renderHeaders(obj) + '\\n' + normalizeNewlines(obj.message)\n  }\n\n  render() {\n    return this._commit\n  }\n\n  withoutSignature() {\n    const commit = normalizeNewlines(this._commit)\n    if (commit.indexOf('\\ngpgsig') === -1) return commit\n    const headers = commit.slice(0, commit.indexOf('\\ngpgsig'))\n    const message = commit.slice(\n      commit.indexOf('-----END PGP SIGNATURE-----\\n') +\n        '-----END PGP SIGNATURE-----\\n'.length\n    )\n    return normalizeNewlines(headers + '\\n' + message)\n  }\n\n  isolateSignature() {\n    const signature = this._commit.slice(\n      this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'),\n      this._commit.indexOf('-----END PGP SIGNATURE-----') +\n        '-----END PGP SIGNATURE-----'.length\n    )\n    return outdent(signature)\n  }\n\n  static async sign(commit, sign, secretKey) {\n    const payload = commit.withoutSignature()\n    const message = GitCommit.justMessage(commit._commit)\n    let { signature } = await sign({ payload, secretKey })\n    // renormalize the line endings to the one true line-ending\n    signature = normalizeNewlines(signature)\n    const headers = GitCommit.justHeaders(commit._commit)\n    const signedCommit =\n      headers + '\\n' + 'gpgsig' + indent(signature) + '\\n' + message\n    // return a new commit object\n    return GitCommit.from(signedCommit)\n  }\n}\n","import { InternalError } from '../errors/InternalError.js'\n\nexport class GitObject {\n  static wrap({ type, object }) {\n    return Buffer.concat([\n      Buffer.from(`${type} ${object.byteLength.toString()}\\x00`),\n      Buffer.from(object),\n    ])\n  }\n\n  static unwrap(buffer) {\n    const s = buffer.indexOf(32) // first space\n    const i = buffer.indexOf(0) // first null value\n    const type = buffer.slice(0, s).toString('utf8') // get type of object\n    const length = buffer.slice(s + 1, i).toString('utf8') // get type of object\n    const actualLength = buffer.length - (i + 1)\n    // verify length\n    if (parseInt(length) !== actualLength) {\n      throw new InternalError(\n        `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`\n      )\n    }\n    return {\n      type,\n      object: Buffer.from(buffer.slice(i + 1)),\n    }\n  }\n}\n","// Modeled after https://github.com/tjfontaine/node-buffercursor\n// but with the goal of being much lighter weight.\nexport class BufferCursor {\n  constructor(buffer) {\n    this.buffer = buffer\n    this._start = 0\n  }\n\n  eof() {\n    return this._start >= this.buffer.length\n  }\n\n  tell() {\n    return this._start\n  }\n\n  seek(n) {\n    this._start = n\n  }\n\n  slice(n) {\n    const r = this.buffer.slice(this._start, this._start + n)\n    this._start += n\n    return r\n  }\n\n  toString(enc, length) {\n    const r = this.buffer.toString(enc, this._start, this._start + length)\n    this._start += length\n    return r\n  }\n\n  write(value, length, enc) {\n    const r = this.buffer.write(value, this._start, length, enc)\n    this._start += length\n    return r\n  }\n\n  copy(source, start, end) {\n    const r = source.copy(this.buffer, this._start, start, end)\n    this._start += r\n    return r\n  }\n\n  readUInt8() {\n    const r = this.buffer.readUInt8(this._start)\n    this._start += 1\n    return r\n  }\n\n  writeUInt8(value) {\n    const r = this.buffer.writeUInt8(value, this._start)\n    this._start += 1\n    return r\n  }\n\n  readUInt16BE() {\n    const r = this.buffer.readUInt16BE(this._start)\n    this._start += 2\n    return r\n  }\n\n  writeUInt16BE(value) {\n    const r = this.buffer.writeUInt16BE(value, this._start)\n    this._start += 2\n    return r\n  }\n\n  readUInt32BE() {\n    const r = this.buffer.readUInt32BE(this._start)\n    this._start += 4\n    return r\n  }\n\n  writeUInt32BE(value) {\n    const r = this.buffer.writeUInt32BE(value, this._start)\n    this._start += 4\n    return r\n  }\n}\n","import { InternalError } from '../errors/InternalError.js'\nimport { BufferCursor } from '../utils/BufferCursor.js'\n\n/**\n * @param {Buffer} delta\n * @param {Buffer} source\n * @returns {Buffer}\n */\nexport function applyDelta(delta, source) {\n  const reader = new BufferCursor(delta)\n  const sourceSize = readVarIntLE(reader)\n\n  if (sourceSize !== source.byteLength) {\n    throw new InternalError(\n      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`\n    )\n  }\n  const targetSize = readVarIntLE(reader)\n  let target\n\n  const firstOp = readOp(reader, source)\n  // Speed optimization - return raw buffer if it's just single simple copy\n  if (firstOp.byteLength === targetSize) {\n    target = firstOp\n  } else {\n    // Otherwise, allocate a fresh buffer and slices\n    target = Buffer.alloc(targetSize)\n    const writer = new BufferCursor(target)\n    writer.copy(firstOp)\n\n    while (!reader.eof()) {\n      writer.copy(readOp(reader, source))\n    }\n\n    const tell = writer.tell()\n    if (targetSize !== tell) {\n      throw new InternalError(\n        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`\n      )\n    }\n  }\n  return target\n}\n\nfunction readVarIntLE(reader) {\n  let result = 0\n  let shift = 0\n  let byte = null\n  do {\n    byte = reader.readUInt8()\n    result |= (byte & 0b01111111) << shift\n    shift += 7\n  } while (byte & 0b10000000)\n  return result\n}\n\nfunction readCompactLE(reader, flags, size) {\n  let result = 0\n  let shift = 0\n  while (size--) {\n    if (flags & 0b00000001) {\n      result |= reader.readUInt8() << shift\n    }\n    flags >>= 1\n    shift += 8\n  }\n  return result\n}\n\nfunction readOp(reader, source) {\n  /** @type {number} */\n  const byte = reader.readUInt8()\n  const COPY = 0b10000000\n  const OFFS = 0b00001111\n  const SIZE = 0b01110000\n  if (byte & COPY) {\n    // copy consists of 4 byte offset, 3 byte size (in LE order)\n    const offset = readCompactLE(reader, byte & OFFS, 4)\n    let size = readCompactLE(reader, (byte & SIZE) >> 4, 3)\n    // Yup. They really did this optimization.\n    if (size === 0) size = 0x10000\n    return source.slice(offset, offset + size)\n  } else {\n    // insert\n    return reader.slice(byte)\n  }\n}\n","// My version of git-list-pack - roughly 15x faster than the original\n// It's used slightly differently - instead of returning a through stream it wraps a stream.\n// (I tried to make it API identical, but that ended up being 2x slower than this version.)\nimport pako from 'pako'\n\nimport { InternalError } from '../errors/InternalError.js'\nimport { StreamReader } from '../utils/StreamReader.js'\n\nexport async function listpack(stream, onData) {\n  const reader = new StreamReader(stream)\n  let PACK = await reader.read(4)\n  PACK = PACK.toString('utf8')\n  if (PACK !== 'PACK') {\n    throw new InternalError(`Invalid PACK header '${PACK}'`)\n  }\n\n  let version = await reader.read(4)\n  version = version.readUInt32BE(0)\n  if (version !== 2) {\n    throw new InternalError(`Invalid packfile version: ${version}`)\n  }\n\n  let numObjects = await reader.read(4)\n  numObjects = numObjects.readUInt32BE(0)\n  // If (for some godforsaken reason) this is an empty packfile, abort now.\n  if (numObjects < 1) return\n\n  while (!reader.eof() && numObjects--) {\n    const offset = reader.tell()\n    const { type, length, ofs, reference } = await parseHeader(reader)\n    const inflator = new pako.Inflate()\n    while (!inflator.result) {\n      const chunk = await reader.chunk()\n      if (!chunk) break\n      inflator.push(chunk, false)\n      if (inflator.err) {\n        throw new InternalError(`Pako error: ${inflator.msg}`)\n      }\n      if (inflator.result) {\n        if (inflator.result.length !== length) {\n          throw new InternalError(\n            `Inflated object size is different from that stated in packfile.`\n          )\n        }\n\n        // Backtrack parser to where deflated data ends\n        await reader.undo()\n        await reader.read(chunk.length - inflator.strm.avail_in)\n        const end = reader.tell()\n        await onData({\n          data: inflator.result,\n          type,\n          num: numObjects,\n          offset,\n          end,\n          reference,\n          ofs,\n        })\n      }\n    }\n  }\n}\n\nasync function parseHeader(reader) {\n  // Object type is encoded in bits 654\n  let byte = await reader.byte()\n  const type = (byte >> 4) & 0b111\n  // The length encoding get complicated.\n  // Last four bits of length is encoded in bits 3210\n  let length = byte & 0b1111\n  // Whether the next byte is part of the variable-length encoded number\n  // is encoded in bit 7\n  if (byte & 0b10000000) {\n    let shift = 4\n    do {\n      byte = await reader.byte()\n      length |= (byte & 0b01111111) << shift\n      shift += 7\n    } while (byte & 0b10000000)\n  }\n  // Handle deltified objects\n  let ofs\n  let reference\n  if (type === 6) {\n    let shift = 0\n    ofs = 0\n    const bytes = []\n    do {\n      byte = await reader.byte()\n      ofs |= (byte & 0b01111111) << shift\n      shift += 7\n      bytes.push(byte)\n    } while (byte & 0b10000000)\n    reference = Buffer.from(bytes)\n  }\n  if (type === 7) {\n    const buf = await reader.read(20)\n    reference = buf\n  }\n  return { type, length, ofs, reference }\n}\n","/* eslint-env node, browser */\n/* global DecompressionStream */\nimport pako from 'pako'\n\nlet supportsDecompressionStream = false\n\nexport async function inflate(buffer) {\n  if (supportsDecompressionStream === null) {\n    supportsDecompressionStream = testDecompressionStream()\n  }\n  return supportsDecompressionStream\n    ? browserInflate(buffer)\n    : pako.inflate(buffer)\n}\n\nasync function browserInflate(buffer) {\n  const ds = new DecompressionStream('deflate')\n  const d = new Blob([buffer]).stream().pipeThrough(ds)\n  return new Uint8Array(await new Response(d).arrayBuffer())\n}\n\nfunction testDecompressionStream() {\n  try {\n    const ds = new DecompressionStream('deflate')\n    if (ds) return true\n  } catch (_) {\n    // no bother\n  }\n  return false\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","var Buffer = require('safe-buffer').Buffer\n\n// prototype class for hash functions\nfunction Hash (blockSize, finalSize) {\n  this._block = Buffer.alloc(blockSize)\n  this._finalSize = finalSize\n  this._blockSize = blockSize\n  this._len = 0\n}\n\nHash.prototype.update = function (data, enc) {\n  if (typeof data === 'string') {\n    enc = enc || 'utf8'\n    data = Buffer.from(data, enc)\n  }\n\n  var block = this._block\n  var blockSize = this._blockSize\n  var length = data.length\n  var accum = this._len\n\n  for (var offset = 0; offset < length;) {\n    var assigned = accum % blockSize\n    var remainder = Math.min(length - offset, blockSize - assigned)\n\n    for (var i = 0; i < remainder; i++) {\n      block[assigned + i] = data[offset + i]\n    }\n\n    accum += remainder\n    offset += remainder\n\n    if ((accum % blockSize) === 0) {\n      this._update(block)\n    }\n  }\n\n  this._len += length\n  return this\n}\n\nHash.prototype.digest = function (enc) {\n  var rem = this._len % this._blockSize\n\n  this._block[rem] = 0x80\n\n  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n  this._block.fill(0, rem + 1)\n\n  if (rem >= this._finalSize) {\n    this._update(this._block)\n    this._block.fill(0)\n  }\n\n  var bits = this._len * 8\n\n  // uint32\n  if (bits <= 0xffffffff) {\n    this._block.writeUInt32BE(bits, this._blockSize - 4)\n\n  // uint64\n  } else {\n    var lowBits = (bits & 0xffffffff) >>> 0\n    var highBits = (bits - lowBits) / 0x100000000\n\n    this._block.writeUInt32BE(highBits, this._blockSize - 8)\n    this._block.writeUInt32BE(lowBits, this._blockSize - 4)\n  }\n\n  this._update(this._block)\n  var hash = this._hash()\n\n  return enc ? hash.toString(enc) : hash\n}\n\nHash.prototype._update = function () {\n  throw new Error('_update must be implemented by subclass')\n}\n\nmodule.exports = Hash\n","/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar inherits = require('inherits')\nvar Hash = require('./hash')\nvar Buffer = require('safe-buffer').Buffer\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha1 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha1, Hash)\n\nSha1.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl1 (num) {\n  return (num << 1) | (num >>> 31)\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha1.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha1.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha1\n","export function toHex(buffer) {\n  let hex = ''\n  for (const byte of new Uint8Array(buffer)) {\n    if (byte < 16) hex += '0'\n    hex += byte.toString(16)\n  }\n  return hex\n}\n","/* eslint-env node, browser */\nimport Hash from 'sha.js/sha1.js'\n\nimport { toHex } from './toHex.js'\n\nlet supportsSubtleSHA1 = null\n\nexport async function shasum(buffer) {\n  if (supportsSubtleSHA1 === null) {\n    supportsSubtleSHA1 = await testSubtleSHA1()\n  }\n  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer)\n}\n\n// This is modeled after @dominictarr's \"shasum\" module,\n// but without the 'json-stable-stringify' dependency and\n// extra type-casting features.\nfunction shasumSync(buffer) {\n  return new Hash().update(buffer).digest('hex')\n}\n\nasync function subtleSHA1(buffer) {\n  const hash = await crypto.subtle.digest('SHA-1', buffer)\n  return toHex(hash)\n}\n\nasync function testSubtleSHA1() {\n  // I'm using a rather crude method of progressive enhancement, because\n  // some browsers that have crypto.subtle.digest don't actually implement SHA-1.\n  try {\n    const hash = await subtleSHA1(new Uint8Array([]))\n    if (hash === 'da39a3ee5e6b4b0d3255bfef95601890afd80709') return true\n  } catch (_) {\n    // no bother\n  }\n  return false\n}\n","import crc32 from 'crc-32'\n\nimport { InternalError } from '../errors/InternalError.js'\nimport { GitObject } from '../models/GitObject'\nimport { BufferCursor } from '../utils/BufferCursor.js'\nimport { applyDelta } from '../utils/applyDelta.js'\nimport { listpack } from '../utils/git-list-pack.js'\nimport { inflate } from '../utils/inflate.js'\nimport { shasum } from '../utils/shasum.js'\n\nfunction decodeVarInt(reader) {\n  const bytes = []\n  let byte = 0\n  let multibyte = 0\n  do {\n    byte = reader.readUInt8()\n    // We keep bits 6543210\n    const lastSeven = byte & 0b01111111\n    bytes.push(lastSeven)\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    multibyte = byte & 0b10000000\n  } while (multibyte)\n  // Now that all the bytes are in big-endian order,\n  // alternate shifting the bits left by 7 and OR-ing the next byte.\n  // And... do a weird increment-by-one thing that I don't quite understand.\n  return bytes.reduce((a, b) => ((a + 1) << 7) | b, -1)\n}\n\n// I'm pretty much copying this one from the git C source code,\n// because it makes no sense.\nfunction otherVarIntDecode(reader, startWith) {\n  let result = startWith\n  let shift = 4\n  let byte = null\n  do {\n    byte = reader.readUInt8()\n    result |= (byte & 0b01111111) << shift\n    shift += 7\n  } while (byte & 0b10000000)\n  return result\n}\n\nexport class GitPackIndex {\n  constructor(stuff) {\n    Object.assign(this, stuff)\n    this.offsetCache = {}\n  }\n\n  static async fromIdx({ idx, getExternalRefDelta }) {\n    const reader = new BufferCursor(idx)\n    const magic = reader.slice(4).toString('hex')\n    // Check for IDX v2 magic number\n    if (magic !== 'ff744f63') {\n      return // undefined\n    }\n    const version = reader.readUInt32BE()\n    if (version !== 2) {\n      throw new InternalError(\n        `Unable to read version ${version} packfile IDX. (Only version 2 supported)`\n      )\n    }\n    if (idx.byteLength > 2048 * 1024 * 1024) {\n      throw new InternalError(\n        `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`\n      )\n    }\n    // Skip over fanout table\n    reader.seek(reader.tell() + 4 * 255)\n    // Get hashes\n    const size = reader.readUInt32BE()\n    const hashes = []\n    for (let i = 0; i < size; i++) {\n      const hash = reader.slice(20).toString('hex')\n      hashes[i] = hash\n    }\n    reader.seek(reader.tell() + 4 * size)\n    // Skip over CRCs\n    // Get offsets\n    const offsets = new Map()\n    for (let i = 0; i < size; i++) {\n      offsets.set(hashes[i], reader.readUInt32BE())\n    }\n    const packfileSha = reader.slice(20).toString('hex')\n    return new GitPackIndex({\n      hashes,\n      crcs: {},\n      offsets,\n      packfileSha,\n      getExternalRefDelta,\n    })\n  }\n\n  static async fromPack({ pack, getExternalRefDelta, onProgress }) {\n    const listpackTypes = {\n      1: 'commit',\n      2: 'tree',\n      3: 'blob',\n      4: 'tag',\n      6: 'ofs-delta',\n      7: 'ref-delta',\n    }\n    const offsetToObject = {}\n\n    // Older packfiles do NOT use the shasum of the pack itself,\n    // so it is recommended to just use whatever bytes are in the trailer.\n    // Source: https://github.com/git/git/commit/1190a1acf800acdcfd7569f87ac1560e2d077414\n    const packfileSha = pack.slice(-20).toString('hex')\n\n    const hashes = []\n    const crcs = {}\n    const offsets = new Map()\n    let totalObjectCount = null\n    let lastPercent = null\n\n    await listpack([pack], async ({ data, type, reference, offset, num }) => {\n      if (totalObjectCount === null) totalObjectCount = num\n      const percent = Math.floor(\n        ((totalObjectCount - num) * 100) / totalObjectCount\n      )\n      if (percent !== lastPercent) {\n        if (onProgress) {\n          await onProgress({\n            phase: 'Receiving objects',\n            loaded: totalObjectCount - num,\n            total: totalObjectCount,\n          })\n        }\n      }\n      lastPercent = percent\n      // Change type from a number to a meaningful string\n      type = listpackTypes[type]\n\n      if (['commit', 'tree', 'blob', 'tag'].includes(type)) {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        }\n      } else if (type === 'ofs-delta') {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        }\n      } else if (type === 'ref-delta') {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        }\n      }\n    })\n\n    // We need to know the lengths of the slices to compute the CRCs.\n    const offsetArray = Object.keys(offsetToObject).map(Number)\n    for (const [i, start] of offsetArray.entries()) {\n      const end =\n        i + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i + 1]\n      const o = offsetToObject[start]\n      const crc = crc32.buf(pack.slice(start, end)) >>> 0\n      o.end = end\n      o.crc = crc\n    }\n\n    // We don't have the hashes yet. But we can generate them using the .readSlice function!\n    const p = new GitPackIndex({\n      pack: Promise.resolve(pack),\n      packfileSha,\n      crcs,\n      hashes,\n      offsets,\n      getExternalRefDelta,\n    })\n\n    // Resolve deltas and compute the oids\n    lastPercent = null\n    let count = 0\n    const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    for (let offset in offsetToObject) {\n      offset = Number(offset)\n      const percent = Math.floor((count * 100) / totalObjectCount)\n      if (percent !== lastPercent) {\n        if (onProgress) {\n          await onProgress({\n            phase: 'Resolving deltas',\n            loaded: count,\n            total: totalObjectCount,\n          })\n        }\n      }\n      count++\n      lastPercent = percent\n\n      const o = offsetToObject[offset]\n      if (o.oid) continue\n      try {\n        p.readDepth = 0\n        p.externalReadDepth = 0\n        const { type, object } = await p.readSlice({ start: offset })\n        objectsByDepth[p.readDepth] += 1\n        const oid = await shasum(GitObject.wrap({ type, object }))\n        o.oid = oid\n        hashes.push(oid)\n        offsets.set(oid, offset)\n        crcs[oid] = o.crc\n      } catch (err) {\n        continue\n      }\n    }\n\n    hashes.sort()\n    return p\n  }\n\n  async toBuffer() {\n    const buffers = []\n    const write = (str, encoding) => {\n      buffers.push(Buffer.from(str, encoding))\n    }\n    // Write out IDX v2 magic number\n    write('ff744f63', 'hex')\n    // Write out version number 2\n    write('00000002', 'hex')\n    // Write fanout table\n    const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4))\n    for (let i = 0; i < 256; i++) {\n      let count = 0\n      for (const hash of this.hashes) {\n        if (parseInt(hash.slice(0, 2), 16) <= i) count++\n      }\n      fanoutBuffer.writeUInt32BE(count)\n    }\n    buffers.push(fanoutBuffer.buffer)\n    // Write out hashes\n    for (const hash of this.hashes) {\n      write(hash, 'hex')\n    }\n    // Write out crcs\n    const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4))\n    for (const hash of this.hashes) {\n      crcsBuffer.writeUInt32BE(this.crcs[hash])\n    }\n    buffers.push(crcsBuffer.buffer)\n    // Write out offsets\n    const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4))\n    for (const hash of this.hashes) {\n      offsetsBuffer.writeUInt32BE(this.offsets.get(hash))\n    }\n    buffers.push(offsetsBuffer.buffer)\n    // Write out packfile checksum\n    write(this.packfileSha, 'hex')\n    // Write out shasum\n    const totalBuffer = Buffer.concat(buffers)\n    const sha = await shasum(totalBuffer)\n    const shaBuffer = Buffer.alloc(20)\n    shaBuffer.write(sha, 'hex')\n    return Buffer.concat([totalBuffer, shaBuffer])\n  }\n\n  async load({ pack }) {\n    this.pack = pack\n  }\n\n  async unload() {\n    this.pack = null\n  }\n\n  async read({ oid }) {\n    if (!this.offsets.get(oid)) {\n      if (this.getExternalRefDelta) {\n        this.externalReadDepth++\n        return this.getExternalRefDelta(oid)\n      } else {\n        throw new InternalError(`Could not read object ${oid} from packfile`)\n      }\n    }\n    const start = this.offsets.get(oid)\n    return this.readSlice({ start })\n  }\n\n  async readSlice({ start }) {\n    if (this.offsetCache[start]) {\n      return Object.assign({}, this.offsetCache[start])\n    }\n    this.readDepth++\n    const types = {\n      0b0010000: 'commit',\n      0b0100000: 'tree',\n      0b0110000: 'blob',\n      0b1000000: 'tag',\n      0b1100000: 'ofs_delta',\n      0b1110000: 'ref_delta',\n    }\n    if (!this.pack) {\n      throw new InternalError(\n        'Tried to read from a GitPackIndex with no packfile loaded into memory'\n      )\n    }\n    const raw = (await this.pack).slice(start)\n    const reader = new BufferCursor(raw)\n    const byte = reader.readUInt8()\n    // Object type is encoded in bits 654\n    const btype = byte & 0b1110000\n    let type = types[btype]\n    if (type === undefined) {\n      throw new InternalError('Unrecognized type: 0b' + btype.toString(2))\n    }\n    // The length encoding get complicated.\n    // Last four bits of length is encoded in bits 3210\n    const lastFour = byte & 0b1111\n    let length = lastFour\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    const multibyte = byte & 0b10000000\n    if (multibyte) {\n      length = otherVarIntDecode(reader, lastFour)\n    }\n    let base = null\n    let object = null\n    // Handle deltified objects\n    if (type === 'ofs_delta') {\n      const offset = decodeVarInt(reader)\n      const baseOffset = start - offset\n      ;({ object: base, type } = await this.readSlice({ start: baseOffset }))\n    }\n    if (type === 'ref_delta') {\n      const oid = reader.slice(20).toString('hex')\n      ;({ object: base, type } = await this.read({ oid }))\n    }\n    // Handle undeltified objects\n    const buffer = raw.slice(reader.tell())\n    object = Buffer.from(await inflate(buffer))\n    // Assert that the object length is as expected.\n    if (object.byteLength !== length) {\n      throw new InternalError(\n        `Packfile told us object would have length ${length} but it had length ${object.byteLength}`\n      )\n    }\n    if (base) {\n      object = Buffer.from(applyDelta(object, base))\n    }\n    // Cache the result based on depth.\n    if (this.readDepth > 3) {\n      // hand tuned for speed / memory usage tradeoff\n      this.offsetCache[start] = { type, object }\n    }\n    return { type, format: 'content', object }\n  }\n}\n","import { BaseError } from './BaseError.js'\n\nexport class InvalidOidError extends BaseError {\n  /**\n   * @param {string} value\n   */\n  constructor(value) {\n    super(`Expected a 40-char hex object id but saw \"${value}\".`)\n    this.code = this.name = InvalidOidError.code\n    this.data = { value }\n  }\n}\n/** @type {'InvalidOidError'} */\nInvalidOidError.code = 'InvalidOidError'\n","import { BaseError } from './BaseError.js'\n\nexport class ObjectTypeError extends BaseError {\n  /**\n   * @param {string} oid\n   * @param {'blob'|'commit'|'tag'|'tree'} actual\n   * @param {'blob'|'commit'|'tag'|'tree'} expected\n   * @param {string} [filepath]\n   */\n  constructor(oid, actual, expected, filepath) {\n    super(\n      `Object ${oid} ${\n        filepath ? `at ${filepath}` : ''\n      }was anticipated to be a ${expected} but it is a ${actual}.`\n    )\n    this.code = this.name = ObjectTypeError.code\n    this.data = { oid, actual, expected, filepath }\n  }\n}\n/** @type {'ObjectTypeError'} */\nObjectTypeError.code = 'ObjectTypeError'\n","import { getIterator } from './getIterator.js'\n\n// Currently 'for await' upsets my linters.\nexport async function forAwait(iterable, cb) {\n  const iter = getIterator(iterable)\n  while (true) {\n    const { value, done } = await iter.next()\n    if (value) await cb(value)\n    if (done) break\n  }\n  if (iter.return) iter.return()\n}\n","import { forAwait } from './forAwait.js'\n\nexport async function collect(iterable) {\n  let size = 0\n  const buffers = []\n  // This will be easier once `for await ... of` loops are available.\n  await forAwait(iterable, value => {\n    buffers.push(value)\n    size += value.byteLength\n  })\n  const result = new Uint8Array(size)\n  let nextIndex = 0\n  for (const buffer of buffers) {\n    result.set(buffer, nextIndex)\n    nextIndex += buffer.byteLength\n  }\n  return result\n}\n","export class FIFO {\n  constructor() {\n    this._queue = []\n  }\n\n  write(chunk) {\n    if (this._ended) {\n      throw Error('You cannot write to a FIFO that has already been ended!')\n    }\n    if (this._waiting) {\n      const resolve = this._waiting\n      this._waiting = null\n      resolve({ value: chunk })\n    } else {\n      this._queue.push(chunk)\n    }\n  }\n\n  end() {\n    this._ended = true\n    if (this._waiting) {\n      const resolve = this._waiting\n      this._waiting = null\n      resolve({ done: true })\n    }\n  }\n\n  destroy(err) {\n    this.error = err\n    this.end()\n  }\n\n  async next() {\n    if (this._queue.length > 0) {\n      return { value: this._queue.shift() }\n    }\n    if (this._ended) {\n      return { done: true }\n    }\n    if (this._waiting) {\n      throw Error(\n        'You cannot call read until the previous call to read has returned!'\n      )\n    }\n    return new Promise(resolve => {\n      this._waiting = resolve\n    })\n  }\n}\n","/*\nIf 'side-band' or 'side-band-64k' capabilities have been specified by\nthe client, the server will send the packfile data multiplexed.\n\nEach packet starting with the packet-line length of the amount of data\nthat follows, followed by a single byte specifying the sideband the\nfollowing data is coming in on.\n\nIn 'side-band' mode, it will send up to 999 data bytes plus 1 control\ncode, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'\nmode it will send up to 65519 data bytes plus 1 control code, for a\ntotal of up to 65520 bytes in a pkt-line.\n\nThe sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain\npackfile data, sideband '2' will be used for progress information that the\nclient will generally print to stderr and sideband '3' is used for error\ninformation.\n\nIf no 'side-band' capability was specified, the server will stream the\nentire packfile without multiplexing.\n*/\nimport { FIFO } from '../utils/FIFO.js'\n\nimport { GitPktLine } from './GitPktLine.js'\n\nexport class GitSideBand {\n  static demux(input) {\n    const read = GitPktLine.streamReader(input)\n    // And now for the ridiculous side-band or side-band-64k protocol\n    const packetlines = new FIFO()\n    const packfile = new FIFO()\n    const progress = new FIFO()\n    // TODO: Use a proper through stream?\n    const nextBit = async function() {\n      const line = await read()\n      // Skip over flush packets\n      if (line === null) return nextBit()\n      // A made up convention to signal there's no more to read.\n      if (line === true) {\n        packetlines.end()\n        progress.end()\n        input.error ? packfile.destroy(input.error) : packfile.end()\n        return\n      }\n      // Examine first byte to determine which output \"stream\" to use\n      switch (line[0]) {\n        case 1: {\n          // pack data\n          packfile.write(line.slice(1))\n          break\n        }\n        case 2: {\n          // progress message\n          progress.write(line.slice(1))\n          break\n        }\n        case 3: {\n          // fatal error message just before stream aborts\n          const error = line.slice(1)\n          progress.write(error)\n          packetlines.end()\n          progress.end()\n          packfile.destroy(new Error(error.toString('utf8')))\n          return\n        }\n        default: {\n          // Not part of the side-band-64k protocol\n          packetlines.write(line)\n        }\n      }\n      // Careful not to blow up the stack.\n      // I think Promises in a tail-call position should be OK.\n      nextBit()\n    }\n    nextBit()\n    return {\n      packetlines,\n      packfile,\n      progress,\n    }\n  }\n  // static mux ({\n  //   protocol, // 'side-band' or 'side-band-64k'\n  //   packetlines,\n  //   packfile,\n  //   progress,\n  //   error\n  // }) {\n  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519\n  //   let output = new PassThrough()\n  //   packetlines.on('data', data => {\n  //     if (data === null) {\n  //       output.write(GitPktLine.flush())\n  //     } else {\n  //       output.write(GitPktLine.encode(data))\n  //     }\n  //   })\n  //   let packfileWasEmpty = true\n  //   let packfileEnded = false\n  //   let progressEnded = false\n  //   let errorEnded = false\n  //   let goodbye = Buffer.concat([\n  //     GitPktLine.encode(Buffer.from('010A', 'hex')),\n  //     GitPktLine.flush()\n  //   ])\n  //   packfile\n  //     .on('data', data => {\n  //       packfileWasEmpty = false\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       packfileEnded = true\n  //       if (!packfileWasEmpty) output.write(goodbye)\n  //       if (progressEnded && errorEnded) output.end()\n  //     })\n  //   progress\n  //     .on('data', data => {\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       progressEnded = true\n  //       if (packfileEnded && errorEnded) output.end()\n  //     })\n  //   error\n  //     .on('data', data => {\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       errorEnded = true\n  //       if (progressEnded && packfileEnded) output.end()\n  //     })\n  //   return output\n  // }\n}\n","import { InvalidOidError } from '../errors/InvalidOidError.js'\nimport { GitSideBand } from '../models/GitSideBand.js'\nimport { forAwait } from '../utils/forAwait.js'\n\nexport async function parseUploadPackResponse(stream) {\n  const { packetlines, packfile, progress } = GitSideBand.demux(stream)\n  const shallows = []\n  const unshallows = []\n  const acks = []\n  let nak = false\n  let done = false\n  return new Promise((resolve, reject) => {\n    // Parse the response\n    forAwait(packetlines, data => {\n      const line = data.toString('utf8').trim()\n      if (line.startsWith('shallow')) {\n        const oid = line.slice(-41).trim()\n        if (oid.length !== 40) {\n          reject(new InvalidOidError(oid))\n        }\n        shallows.push(oid)\n      } else if (line.startsWith('unshallow')) {\n        const oid = line.slice(-41).trim()\n        if (oid.length !== 40) {\n          reject(new InvalidOidError(oid))\n        }\n        unshallows.push(oid)\n      } else if (line.startsWith('ACK')) {\n        const [, oid, status] = line.split(' ')\n        acks.push({ oid, status })\n        if (!status) done = true\n      } else if (line.startsWith('NAK')) {\n        nak = true\n        done = true\n      } else {\n        done = true\n        nak = true\n      }\n      if (done) {\n        stream.error\n          ? reject(stream.error)\n          : resolve({ shallows, unshallows, acks, nak, packfile, progress })\n      }\n    }).finally(() => {\n      if (!done) {\n        stream.error\n          ? reject(stream.error)\n          : resolve({ shallows, unshallows, acks, nak, packfile, progress })\n      }\n    })\n  })\n}\n","/*\n * Import internal data parsers and structures from isomorphic-git. These\n * exports are not available in the npm version of isomorphic-git, which is why\n * we use one from the git repository.\n *\n * This file heavily relies on isomorphic-git internals to parse Git data formats\n * such as PACK, trees, deltas, etc.\n */\nimport './isomorphic-git.d.ts';\nimport { GitPktLine } from 'isomorphic-git/src/models/GitPktLine.js';\nimport { GitTree } from 'isomorphic-git/src/models/GitTree.js';\nimport { GitAnnotatedTag } from 'isomorphic-git/src/models/GitAnnotatedTag.js';\nimport { GitCommit } from 'isomorphic-git/src/models/GitCommit.js';\nimport { GitPackIndex } from 'isomorphic-git/src/models/GitPackIndex.js';\nimport { collect } from 'isomorphic-git/src/internal-apis.js';\nimport { parseUploadPackResponse } from 'isomorphic-git/src/wire/parseUploadPackResponse.js';\nimport { ObjectTypeError } from 'isomorphic-git/src/errors/ObjectTypeError.js';\nimport { Buffer } from 'buffer';\n\n/**\n * A polyfill for the Buffer class. We need it because isomorphic-git uses it internally.\n * The isomorphic-git version released via npm shipes a Buffer implementation, but we're\n * using a version cloned from the git repository which assumes a global Buffer is available.\n */\nif (typeof window !== 'undefined') {\n\twindow.Buffer = Buffer;\n}\n\n/**\n * Downloads specific files from a git repository.\n * It uses the git protocol over HTTP to fetch the files. It only uses\n * three HTTP requests regardless of the number of paths requested.\n *\n * @param repoUrl The URL of the git repository.\n * @param fullyQualifiedBranchName The full name of the branch to fetch from (e.g., 'refs/heads/main').\n * @param filesPaths An array of all the file paths to fetch from the repository. Does **not** accept\n *                   patterns, wildcards, directory paths. All files must be explicitly listed.\n * @returns A record where keys are file paths and values are the retrieved file contents.\n */\nexport async function sparseCheckout(\n\trepoUrl: string,\n\tcommitHash: string,\n\tfilesPaths: string[]\n) {\n\tconst treesIdx = await fetchWithoutBlobs(repoUrl, commitHash);\n\tconst objects = await resolveObjects(treesIdx, commitHash, filesPaths);\n\n\tconst blobsIdx = await fetchObjects(\n\t\trepoUrl,\n\t\tfilesPaths.map((path) => objects[path].oid)\n\t);\n\n\tconst fetchedPaths: Record<string, any> = {};\n\tawait Promise.all(\n\t\tfilesPaths.map(async (path) => {\n\t\t\tfetchedPaths[path] = await extractGitObjectFromIdx(\n\t\t\t\tblobsIdx,\n\t\t\t\tobjects[path].oid\n\t\t\t);\n\t\t})\n\t);\n\treturn fetchedPaths;\n}\n\nexport type FileTreeFile = {\n\tname: string;\n\ttype: 'file';\n};\nexport type FileTreeFolder = {\n\tname: string;\n\ttype: 'folder';\n\tchildren: FileTree[];\n};\nexport type FileTree = FileTreeFile | FileTreeFolder;\n\nexport type GitRef = {\n\tvalue: string;\n\ttype?: 'branch' | 'commit' | 'refname' | 'infer';\n};\n\n/**\n * Lists all files in a git repository.\n *\n * See https://git-scm.com/book/en/v2/Git-Internals-Git-Objects for more information.\n *\n * @param repoUrl The URL of the git repository.\n * @param commitHash The commit hash to fetch from.\n * @returns A list of all files in the repository.\n */\nexport async function listGitFiles(\n\trepoUrl: string,\n\tcommitHash: string\n): Promise<FileTree[]> {\n\tconst treesIdx = await fetchWithoutBlobs(repoUrl, commitHash);\n\tconst rootTree = await resolveAllObjects(treesIdx, commitHash);\n\tif (!rootTree?.object) {\n\t\treturn [];\n\t}\n\n\treturn gitTreeToFileTree(rootTree);\n}\n\n/**\n * Resolves a ref description, e.g. a branch name, to a commit hash.\n *\n * @param repoUrl The URL of the git repository.\n * @param ref The branch name or commit hash.\n * @returns The commit hash.\n */\nexport async function resolveCommitHash(repoUrl: string, ref: GitRef) {\n\tif (ref.type === 'infer' || ref.type === undefined) {\n\t\tif (['', 'HEAD'].includes(ref.value)) {\n\t\t\tref = {\n\t\t\t\tvalue: ref.value,\n\t\t\t\ttype: 'refname',\n\t\t\t};\n\t\t} else if (typeof ref.value === 'string' && ref.value.length === 40) {\n\t\t\tref = {\n\t\t\t\tvalue: ref.value,\n\t\t\t\ttype: 'commit',\n\t\t\t};\n\t\t}\n\t}\n\tif (ref.type === 'branch') {\n\t\tref = {\n\t\t\tvalue: `refs/heads/${ref.value}`,\n\t\t\ttype: 'refname',\n\t\t};\n\t}\n\tswitch (ref.type) {\n\t\tcase 'commit':\n\t\t\treturn ref.value;\n\t\tcase 'refname': {\n\t\t\tconst refs = await listGitRefs(repoUrl, ref.value);\n\t\t\tif (!(ref.value in refs)) {\n\t\t\t\tthrow new Error(`Branch ${ref.value} not found`);\n\t\t\t}\n\t\t\treturn refs[ref.value];\n\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid ref type: ${ref.type}`);\n\t}\n}\n\nfunction gitTreeToFileTree(tree: GitTree): FileTree[] {\n\treturn tree.object\n\t\t.map((branch) => {\n\t\t\tif (branch.type === 'blob') {\n\t\t\t\treturn {\n\t\t\t\t\tname: branch.path,\n\t\t\t\t\ttype: 'file',\n\t\t\t\t} as FileTreeFile;\n\t\t\t} else if (branch.type === 'tree' && branch.object) {\n\t\t\t\treturn {\n\t\t\t\t\tname: branch.path,\n\t\t\t\t\ttype: 'folder',\n\t\t\t\t\tchildren: gitTreeToFileTree(branch as any as GitTree),\n\t\t\t\t} as FileTreeFolder;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t})\n\t\t.filter((entry) => !!entry?.name) as FileTree[];\n}\n\n/**\n * Retrieves a list of refs from a git repository.\n *\n * See https://git-scm.com/book/en/v2/Git-Internals-Git-References for more information.\n *\n * @param repoUrl The URL of the git repository. For example: https://github.com/WordPress/gutenberg.git\n * @param fullyQualifiedBranchPrefix The prefix of the refs to fetch. For example: refs/heads/my-feature-branch\n * @returns A map of refs to their corresponding commit hashes.\n */\nexport async function listGitRefs(\n\trepoUrl: string,\n\tfullyQualifiedBranchPrefix: string\n) {\n\tconst packbuffer = Buffer.from(\n\t\tawait collect([\n\t\t\tGitPktLine.encode(`command=ls-refs\\n`),\n\t\t\tGitPktLine.encode(`agent=git/2.37.3\\n`),\n\t\t\tGitPktLine.encode(`object-format=sha1\\n`),\n\t\t\tGitPktLine.delim(),\n\t\t\tGitPktLine.encode(`peel\\n`),\n\t\t\tGitPktLine.encode(`ref-prefix ${fullyQualifiedBranchPrefix}\\n`),\n\t\t\tGitPktLine.flush(),\n\t\t])\n\t);\n\n\tconst response = await fetch(repoUrl + '/git-upload-pack', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/x-git-upload-pack-advertisement',\n\t\t\t'content-type': 'application/x-git-upload-pack-request',\n\t\t\t'Content-Length': `${packbuffer.length}`,\n\t\t\t'Git-Protocol': 'version=2',\n\t\t},\n\t\tbody: packbuffer,\n\t});\n\n\tconst refs: Record<string, string> = {};\n\tfor await (const line of parseGitResponseLines(response)) {\n\t\tconst spaceAt = line.indexOf(' ');\n\t\tconst ref = line.slice(0, spaceAt);\n\t\tconst name = line.slice(spaceAt + 1, line.length - 1);\n\t\trefs[name] = ref;\n\t}\n\treturn refs;\n}\n\nasync function fetchWithoutBlobs(repoUrl: string, commitHash: string) {\n\tconst packbuffer = Buffer.from(\n\t\tawait collect([\n\t\t\tGitPktLine.encode(\n\t\t\t\t`want ${commitHash} multi_ack_detailed no-done side-band-64k thin-pack ofs-delta agent=git/2.37.3 filter \\n`\n\t\t\t),\n\t\t\tGitPktLine.encode(`filter blob:none\\n`),\n\t\t\tGitPktLine.encode(`shallow ${commitHash}\\n`),\n\t\t\tGitPktLine.encode(`deepen 1\\n`),\n\t\t\tGitPktLine.flush(),\n\t\t\tGitPktLine.encode(`done\\n`),\n\t\t\tGitPktLine.encode(`done\\n`),\n\t\t])\n\t);\n\n\tconst response = await fetch(repoUrl + '/git-upload-pack', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/x-git-upload-pack-advertisement',\n\t\t\t'content-type': 'application/x-git-upload-pack-request',\n\t\t\t'Content-Length': `${packbuffer.length}`,\n\t\t},\n\t\tbody: packbuffer,\n\t});\n\n\tconst iterator = streamToIterator(response.body!);\n\tconst parsed = await parseUploadPackResponse(iterator);\n\tconst packfile = Buffer.from(await collect(parsed.packfile));\n\tconst idx = await GitPackIndex.fromPack({\n\t\tpack: packfile,\n\t});\n\tconst originalRead = idx.read as any;\n\tidx.read = async function ({ oid, ...rest }: { oid: string }) {\n\t\tconst result = await originalRead.call(this, { oid, ...rest });\n\t\tresult.oid = oid;\n\t\treturn result;\n\t};\n\treturn idx;\n}\n\nasync function resolveAllObjects(idx: GitPackIndex, commitHash: string) {\n\tconst commit = await idx.read({\n\t\toid: commitHash,\n\t});\n\treadObject(commit);\n\n\tconst rootItem = await idx.read({ oid: commit.object.tree });\n\tconst items = [rootItem];\n\twhile (items.length > 0) {\n\t\tconst tree = items.pop();\n\t\tconst readItem = await idx.read({ oid: tree.oid });\n\t\treadObject(readItem);\n\t\ttree.object = readItem.object;\n\t\tif (readItem.type === 'tree') {\n\t\t\tfor (const subitem of readItem.object) {\n\t\t\t\tif (subitem.type === 'tree') {\n\t\t\t\t\titems.push(subitem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn rootItem;\n}\n\nasync function resolveObjects(\n\tidx: GitPackIndex,\n\tcommitHash: string,\n\tpaths: string[]\n) {\n\tconst commit = await idx.read({\n\t\toid: commitHash,\n\t});\n\treadObject(commit);\n\n\tconst rootTree = await idx.read({ oid: commit.object.tree });\n\treadObject(rootTree);\n\n\t// Resolve refs to fetch\n\tconst resolvedOids: Record<string, any> = {};\n\tfor (const path of paths) {\n\t\tlet currentObject = rootTree;\n\t\tconst segments = path.split('/');\n\t\tfor (const segment of segments) {\n\t\t\tif (currentObject.type !== 'tree') {\n\t\t\t\tthrow new Error(`Path not found in the repo: ${path}`);\n\t\t\t}\n\n\t\t\tlet found = false;\n\t\t\tfor (const item of currentObject.object) {\n\t\t\t\tif (item.path === segment) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcurrentObject = await idx.read({ oid: item.oid });\n\t\t\t\t\t\treadObject(currentObject);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcurrentObject = item;\n\t\t\t\t\t}\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tthrow new Error(`Path not found in the repo: ${path}`);\n\t\t\t}\n\t\t}\n\t\tresolvedOids[path] = currentObject;\n\t}\n\treturn resolvedOids;\n}\n\n// Request oid for each resolvedRef\nasync function fetchObjects(url: string, objectHashes: string[]) {\n\tconst packbuffer = Buffer.from(\n\t\tawait collect([\n\t\t\t...objectHashes.map((objectHash) =>\n\t\t\t\tGitPktLine.encode(\n\t\t\t\t\t`want ${objectHash} multi_ack_detailed no-done side-band-64k thin-pack ofs-delta agent=git/2.37.3 \\n`\n\t\t\t\t)\n\t\t\t),\n\t\t\tGitPktLine.flush(),\n\t\t\tGitPktLine.encode(`done\\n`),\n\t\t])\n\t);\n\n\tconst response = await fetch(url + '/git-upload-pack', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/x-git-upload-pack-advertisement',\n\t\t\t'content-type': 'application/x-git-upload-pack-request',\n\t\t\t'Content-Length': `${packbuffer.length}`,\n\t\t},\n\t\tbody: packbuffer,\n\t});\n\n\tconst iterator = streamToIterator(response.body!);\n\tconst parsed = await parseUploadPackResponse(iterator);\n\tconst packfile = Buffer.from(await collect(parsed.packfile));\n\treturn await GitPackIndex.fromPack({\n\t\tpack: packfile,\n\t});\n}\n\nasync function extractGitObjectFromIdx(idx: GitPackIndex, objectHash: string) {\n\tconst tree = await idx.read({ oid: objectHash });\n\treadObject(tree);\n\n\tif (tree.type === 'blob') {\n\t\treturn tree.object;\n\t}\n\n\tconst files: Record<string, any> = {};\n\tfor (const { path, oid, type } of tree.object) {\n\t\tif (type === 'blob') {\n\t\t\tconst object = await idx.read({ oid });\n\t\t\treadObject(object);\n\t\t\tfiles[path] = object.object;\n\t\t} else if (type === 'tree') {\n\t\t\tfiles[path] = await extractGitObjectFromIdx(idx, oid);\n\t\t}\n\t}\n\treturn files;\n}\n\nfunction readObject(result: any) {\n\tif (!(result.object instanceof Buffer)) {\n\t\treturn;\n\t}\n\tswitch (result.type) {\n\t\tcase 'commit':\n\t\t\tresult.object = GitCommit.from(result.object).parse();\n\t\t\tbreak;\n\t\tcase 'tree':\n\t\t\tresult.object = (GitTree.from(result.object) as any).entries();\n\t\t\tbreak;\n\t\tcase 'blob':\n\t\t\tresult.object = new Uint8Array(result.object);\n\t\t\tresult.format = 'content';\n\t\t\tbreak;\n\t\tcase 'tag':\n\t\t\tresult.object = GitAnnotatedTag.from(result.object).parse();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new ObjectTypeError(\n\t\t\t\tresult.oid,\n\t\t\t\tresult.type,\n\t\t\t\t'blob|commit|tag|tree'\n\t\t\t);\n\t}\n}\n\nasync function* parseGitResponseLines(response: Response) {\n\tconst text = await response.text();\n\tlet at = 0;\n\n\twhile (at <= text.length) {\n\t\tconst lineLength = parseInt(text.substring(at, at + 4), 16);\n\t\tif (lineLength === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tconst line = text.substring(at + 4, at + lineLength);\n\t\tyield line;\n\t\tat += lineLength;\n\t}\n}\n\nfunction streamToIterator(stream: any) {\n\t// Use native async iteration if it's available.\n\tif (stream[Symbol.asyncIterator]) {\n\t\treturn stream;\n\t}\n\tconst reader = stream.getReader();\n\treturn {\n\t\tnext() {\n\t\t\treturn reader.read();\n\t\t},\n\t\treturn() {\n\t\t\treader.releaseLock();\n\t\t\treturn {};\n\t\t},\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t};\n}\n","import { normalizePath } from '@php-wasm/util';\nimport { FileTree } from './git-sparse-checkout';\n\nexport function listDescendantFiles(files: FileTree[], selectedPath: string) {\n\tselectedPath = normalizePath(selectedPath);\n\tconst isRoot = ['', '.', '/'].includes(selectedPath);\n\n\tlet currentTree: FileTree[] | null = files;\n\tif (isRoot) {\n\t\tselectedPath = '';\n\t} else {\n\t\tconst segments = selectedPath.split('/');\n\t\tfor (const segment of segments) {\n\t\t\tconst file = currentTree?.find(\n\t\t\t\t(file) => file.name === segment\n\t\t\t) as FileTree;\n\t\t\tif (file?.type === 'folder') {\n\t\t\t\tcurrentTree = file.children;\n\t\t\t} else if (file) {\n\t\t\t\treturn [file.name];\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the list of files to checkout based on the mapping\n\tconst descendants: string[] = [];\n\tconst stack = [{ tree: currentTree, path: selectedPath }];\n\twhile (stack.length > 0) {\n\t\tconst { tree, path } = stack.pop() as {\n\t\t\ttree: FileTree[];\n\t\t\tpath: string;\n\t\t};\n\t\tfor (const file of tree) {\n\t\t\tconst filePath = `${path}${path ? '/' : ''}${file.name}`;\n\t\t\tif (file.type === 'folder') {\n\t\t\t\tstack.push({\n\t\t\t\t\ttree: file.children,\n\t\t\t\t\tpath: filePath,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdescendants.push(filePath);\n\t\t\t}\n\t\t}\n\t}\n\treturn descendants;\n}\n\nexport function removePathPrefix(path: string, prefix: string) {\n\tif (path.startsWith(prefix)) {\n\t\treturn path.substring(prefix.length);\n\t}\n\treturn path;\n}\n"],"names":["createClient","githubToken","Octokit","filesListToObject","files","root","result","file","getFilesFromDirectory","octokit","owner","repo","ref","path","options","onProgress","filePromises","directoryPromises","content","item","getFileContent","filesInDirs","dir","semaphore","Semaphore","release","fileContent","base64ToUint8Array","base64","binaryString","len","bytes","i","getArtifact","pull_number","workflow_id","pullRequest","runId","_a","artifacts","mayPush","repository","headers","createOrUpdateBranch","branch","newHead","fork","user","createCommit","message","parentSha","treeSha","sha","createTree","changeset","tree","createTreeNodes","newTreeSha","blobsPromises","createTreeNode","deleteFile","blobs","blob","blobSemaphore","stringContent","uint8ArrayToBase64","binary","iterateFiles","playground","exceptPaths","normalizePath","stack","currentParent","absPath","joinPaths","filesBefore","filesAfter","changes","seenFilesAfter","fileAfter","before","after","uint8arraysEqual","pathBefore","a","b","val","index","directoryHandleFromMountDevice","device","opfsPathToDirectoryHandle","opfsPath","parts","p","handle","part","directoryHandleToOpfsPath","directoryHandle","pathParts","clearContentsFromMountDevice","mountDevice","parentHandle","name","fromValue","value","queue","getIterator","iterable","StreamReader","stream","n","done","buffers","lengthBuffers","nextbuffer","acc","buffer","padHex","s","GitPktLine","line","length","hexlength","reader","err","BaseError","json","e","InternalError","UnsafeFilepathError","filepath","compareStrings","comparePath","compareTreeEntryPath","appendSlashIfDir","entry","mode2type","mode","parseBuffer","_entries","cursor","space","nullchar","type","oid","limitModeToAllowed","nudgeIntoShape","GitTree","entries","formatAuthor","email","timestamp","timezoneOffset","formatTimezoneOffset","minutes","sign","simpleSign","negateExceptForZero","hours","strHours","strMinutes","normalizeNewlines","str","parseAuthor","author","offset","parseTimezoneOffset","GitAnnotatedTag","tag","obj","hs","h","key","signature","secretKey","payload","signedTag","indent","x","outdent","GitCommit","commit","committer","signedCommit","GitObject","object","actualLength","BufferCursor","r","enc","source","start","end","applyDelta","delta","sourceSize","readVarIntLE","targetSize","target","firstOp","readOp","writer","tell","shift","byte","readCompactLE","flags","size","COPY","OFFS","SIZE","listpack","onData","PACK","version","numObjects","ofs","reference","parseHeader","inflator","pako","chunk","supportsDecompressionStream","inflate","browserInflate","ds","d","inherits_browserModule","ctor","superCtor","TempCtor","base64Js","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","code","getLens","b64","validLen","placeHoldersLen","lens","_byteLength","tmp","arr","curByte","tripletToBase64","num","encodeChunk","uint8","output","extraBytes","maxChunkLength","len2","ieee754","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","c","rt","require$$0","require$$1","customInspectSymbol","exports","Buffer","SlowBuffer","K_MAX_LENGTH","typedArraySupport","proto","createBuffer","buf","arg","encodingOrOffset","allocUnsafe","from","fromString","fromArrayView","isInstance","fromArrayBuffer","valueOf","fromObject","assertSize","alloc","fill","encoding","checked","string","actual","fromArrayLike","array","arrayView","copy","byteOffset","numberIsNaN","y","list","pos","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","max","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","arrayIndexOf","indexSize","arrLength","valLength","read","foundIndex","found","j","hexWrite","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","base64Write","ucs2Write","utf16leToBytes","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","ret","out","hexSliceLookupTable","newBuf","checkOffset","ext","noAssert","mul","defineBigIntMethod","validateNumber","first","last","boundsError","lo","hi","checkInt","min","maxBytes","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","limit","sub","checkIEEE754","writeFloat","littleEndian","writeDouble","targetStart","errors","E","sym","getMessage","Base","range","input","msg","received","addNumericalSeparator","checkBounds","INVALID_BASE64_RE","base64clean","units","leadSurrogate","byteArray","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","copyProps","module","SafeBuffer","Hash","blockSize","finalSize","data","block","accum","assigned","remainder","rem","bits","lowBits","highBits","hash","inherits","require$$2","K","W","Sha1","rotl1","rotl5","rotl30","ft","M","t","H","sha1","toHex","hex","supportsSubtleSHA1","shasum","testSubtleSHA1","subtleSHA1","shasumSync","decodeVarInt","multibyte","lastSeven","otherVarIntDecode","startWith","GitPackIndex","stuff","idx","getExternalRefDelta","hashes","offsets","packfileSha","pack","listpackTypes","offsetToObject","crcs","totalObjectCount","lastPercent","percent","offsetArray","o","crc","crc32","count","objectsByDepth","write","fanoutBuffer","crcsBuffer","offsetsBuffer","totalBuffer","shaBuffer","types","raw","btype","lastFour","base","baseOffset","InvalidOidError","ObjectTypeError","expected","forAwait","cb","iter","collect","nextIndex","FIFO","resolve","GitSideBand","packetlines","packfile","progress","nextBit","error","parseUploadPackResponse","shallows","unshallows","acks","nak","reject","status","sparseCheckout","repoUrl","commitHash","filesPaths","treesIdx","fetchWithoutBlobs","objects","resolveObjects","blobsIdx","fetchObjects","fetchedPaths","extractGitObjectFromIdx","listGitFiles","rootTree","resolveAllObjects","gitTreeToFileTree","resolveCommitHash","refs","listGitRefs","fullyQualifiedBranchPrefix","packbuffer","response","parseGitResponseLines","spaceAt","iterator","streamToIterator","originalRead","rest","readObject","rootItem","items","readItem","subitem","paths","resolvedOids","currentObject","segments","segment","url","objectHashes","objectHash","text","at","lineLength","listDescendantFiles","selectedPath","isRoot","currentTree","descendants","filePath","removePathPrefix","prefix"],"mappings":"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","x_google_ignoreList":[27,28,29,30,31,32,33]}